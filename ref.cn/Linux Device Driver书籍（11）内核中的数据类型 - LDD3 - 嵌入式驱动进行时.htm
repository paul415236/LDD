<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://blog.chinaunix.net/u2/78225/showart.php?id=1270138 -->
<HTML><HEAD><TITLE>Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gbk"><LINK 
href="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/index.css" 
rel=stylesheet></LINK><LINK title="ChinaUnix Blog RSS Feed" 
href="http://blog.chinaunix.net/u/rss.php?id=78225" type=application/rss+xml 
rel=alternate></LINK>
<META content="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时" 
name=keywords>
<META 
content="中国最大的IT技术博客-ChinaUnix博客：Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时" 
name=description>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY style="BACKGROUND: #ffffff" leftMargin=0 topMargin=0 align="center" 
marginheight="0" marginwidth="0">
<TABLE style="BORDER-COLLAPSE: collapse; HEIGHT: 25px" height=25 cellSpacing=0 
cellPadding=0 width="100%" align=center 
background="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/tophem1.gif" 
border=0>
  <TBODY>
  <TR>
    <TD id=tool-bar noWrap align=left>&nbsp; <A 
      href="http://blog.chinaunix.net/" target=_blank>博客首页</A> <A 
      href="http://blog.chinaunix.net/register.php" target=_blank>注册</A> <A 
      href="http://bbs.chinaunix.net/forumdisplay.php?fid=51" 
      target=_blank>建议与交流</A> <A href="http://blog.chinaunix.net/top/" 
      target=_blank>排行榜</A> <A 
      onclick="NewWindows('http://www.cublog.cn/addlink.php?url='+location.href+'&amp;title='+document.title);return false;" 
      href="http://blog.chinaunix.net/u2/78225/" target=_blank>加入友情链接</A> </TD>
    <FORM id=loginForm action=/search.php method=get target=_blank>
    <TD noWrap align=right><IMG id=starimg height=12 alt="" 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/userstar.gif" 
      width=55 border=0> <A id=star title=给此博客推荐值 
      onclick="NewWindows(this.href);return false;" 
      href="http://blog.chinaunix.net/u2/star.php?blogid=78225">推荐</A> <A 
      id=complaint title=投诉此博客 onclick="NewWindows(this.href);return false;" 
      href="http://blog.chinaunix.net/u2/complaint.php?blogid=78225">投诉</A> 
      搜索：<INPUT name=q> <INPUT class=button1 type=submit value=搜索> <A 
      href="http://blog.chinaunix.net/help/">帮助</A></TD></FORM></TR></TBODY></TABLE>
<SCRIPT language=javascript>
<!--

navHover = function() {
var lis = document.getElementById("navmenu").getElementsByTagName("LI");
for (var i=0; i<lis.length; i++) {
lis[i].onmouseover=function() {
this.className+=" iehover";
}
lis[i].onmouseout=function() {
this.className=this.className.replace(new RegExp(" iehover\\b"), "");
}
}
}

function NewWindows(shref){
var xx=(window.screen.width-450)/2;
var yy=(window.screen.height-200)/2;
pp=window.open(shref,"win","menubar=no,location=no,resizable=no,scrollbars=no,status=no,left="+xx+",top="+yy+",Width=450,Height=200");
}
function $(s){return document.getElementById(s);}
//-->
</SCRIPT>

<TABLE 
style="BACKGROUND-IMAGE: url(http://www.cublog.cn/templates/newgreen/images/bg_top.gif); BACKGROUND-REPEAT: no-repeat; BORDER-COLLAPSE: collapse" 
height=143 cellSpacing=0 cellPadding=0 width="100%" align=center bgColor=#187218 
border=0>
  <TBODY>
  <TR>
    <TD width=360></TD>
    <TD align=middle width=500>
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"><FONT style="FONT-SIZE: 14pt" 
      color=#ffffff><B>
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"><FONT style="FONT-SIZE: 14px" 
      color=#ffffff><B>嵌入式驱动进行时 </B></FONT></P></B></FONT>
      <P></P></TD>
    <TD width=360>学习学习再学习！</TD></TR>
  <TR>
    <TD colSpan=3>
      <TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
      cellPadding=0 width=980 border=0>
        <TBODY>
        <TR>
          <TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<TABLE style="BORDER-COLLAPSE: collapse" height=27 cellSpacing=0 cellPadding=0 
width="100%" align=center bgColor=#ffffff 
background="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_menu.gif" 
border=0>
  <TBODY>
  <TR>
    <TD align=middle width=30><IMG height=29 alt="" 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/img_menu_left.gif" 
      width=26 border=0></TD>
    <TD width=200><A class=list1 href="http://yuchuan2008.cublog.cn/" 
      target=_blank>yuchuan2008.cublog.cn</A> </TD>
    <TD style="COLOR: #2a5200" align=right width=750>
      <UL id=navmenu>
        <LI class=ul0><A class=list1 href="http://control.cublog.cn/" 
        target=_blank>管理博客</A> </LI>
        <LI class=ul0><A class=list1 
        href="http://control.cublog.cn/article_new.php" target=_blank>发表文章</A> 
        </LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/guestbook.html">留言</A> </LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/links.html">收藏夹</A> 
        <!-- 0 --></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/group.html">博客圈</A> </LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/music.html">音乐</A> 
        <!-- 0 --></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/photo.html">相册</A> 
        <!-- 0 --></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/article.html">文章</A> 
        <UL class=ul1>
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96075.html">・ 
          Bootloader（转载）<!-- a96075 --></A><!-- 96075 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95828.html">・ 
          嵌入式C语言基础（转载）<!-- a95828 --></A><!-- 95828 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95774.html">・ 
          Linux设备驱动（转载）&nbsp;&nbsp;&nbsp;<FONT face="Wingdings 3">}</FONT></A>
          <UL class=ul2>
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96083.html">・ LDD3<!-- a96083 --></A><!-- 96083 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96060.html">・ 
            Linux设备驱动理论<!-- a96060 --></A><!-- 96060 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95966.html">・ 
            Linux字符设备驱动<!-- a95966 --></A><!-- 95966 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95967.html">・ 
            Linux块设备驱动<!-- a95967 --></A><!-- 95967 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95969.html">・ 
            Linux总线驱动<!-- a95969 --></A><!-- 95969 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95968.html">・ 
            Linux网络设备驱动<!-- a95968 --></A><!-- 95968 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96065.html">・ 
            Linux复杂设备驱动<!-- a96065 --></A><!-- 96065 --> </LI></UL>
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96073.html">・ 
          Linux内核（转载）<!-- a96073 --></A><!-- 96073 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96055.html">・ 
          学习&amp;&amp;工作&nbsp;&nbsp;&nbsp;<FONT face="Wingdings 3">}</FONT></A>
          <UL class=ul2>
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96507.html">・ 
            嵌入式系统开发<!-- a96507 --></A><!-- 96507 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96918.html">・ 
            Embest 2410<!-- a96918 --></A><!-- 96918 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96639.html">・ 
            LINUX下C应用编程<!-- a96639 --></A><!-- 96639 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96508.html">・ 
            Linux驱动开发<!-- a96508 --></A><!-- 96508 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96509.html">・ 测试技术<!-- a96509 --></A><!-- 96509 --> </LI></UL>
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95777.html">・ 
          交叉编译（转载）<!-- a95777 --></A><!-- 95777 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96080.html">・ 
          ARM技术（转载）<!-- a96080 --></A><!-- 96080 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_97102.html">・ 
          嵌入式系统开发（转载）<!-- a97102 --></A><!-- 97102 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95775.html">・ 
          Linux基础（转载）<!-- a95775 --></A><!-- 95775 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95854.html">・ 
          Linux应用程序（转载）<!-- a95854 --></A><!-- 95854 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96053.html">・ 
          其他<!-- a96053 --></A><!-- 96053 --> </LI></UL></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/index.html">首页</A> </LI></UL></TD>
    <TD width=10></TD></TR>
  <TR>
    <TD colSpan=4>
      <TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
      cellPadding=0 width=980 border=0>
        <TBODY>
        <TR>
          <TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<SCRIPT language=javascript>
function $(s){return document.getElementById(s);}
function ShowHideDiv(divid,iImg){
if($(divid).style.display == "none"){
iImg.src="../../templates/newgreen/images/dot2.gif";
$(divid).style.display = "block";
iImg.title="收起";
}else{
iImg.src="../../templates/newgreen/images/dot4.gif";
$(divid).style.display = "none";
iImg.title="展开";
}
}
navHover();
</SCRIPT>

<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD height=3></TD></TR></TBODY></TABLE><BR>
<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
cellPadding=0 width="90%" align=center border=0>
  <TBODY>
  <TR>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_left_top.gif" 
      border=0></TD>
    <TD 
    background="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_top.gif">
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"></P></TD>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_right_top.gif" 
      border=0></TD></TR>
  <TR>
    <TD width=18 
    background="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_left.gif"></TD>
    <TD align=middle bgColor=#f5fdee><BR><FONT style="FONT-SIZE: 14pt" 
      color=#295200><B>Linux Device Driver书籍（11）内核中的数据类型</B></FONT> 
      <TABLE style="BORDER-COLLAPSE: collapse" borderColor=#a5bd6b cellSpacing=1 
      cellPadding=0 width="100%" border=1>
        <TBODY>
        <TR>
          <TD align=middle>
            <TABLE style="BORDER-COLLAPSE: collapse; WORD-WRAP: break-word" 
            cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD align=middle>
                  <TABLE 
                  style="BORDER-COLLAPSE: collapse; WORD-WRAP: break-word" 
                  cellSpacing=0 cellPadding=0 width="100%" border=0>
                    <TBODY>
                    <TR>
                      <TD>
                        <DIV id=art style="MARGIN: 15px">
                        <DIV>第&nbsp;11&nbsp;章&nbsp;内核中的数据类型</DIV>
                        <DIV>
                        <P>在我们进入更高级主题之前, 我们需要停下来快速关注一下可移植性问题. 现代版本的 Linux 
                        内核是高度可移植的, 它正运行在很多不同体系上. 由于 Linux 内核的多平台特性, 
                        打算做认真使用的驱动应当也是可移植的.</P>
                        <P>但是内核代码的一个核心问题是不但能够存取已知长度的数据项(例如, 
                        文件系统数据结构或者设备单板上的寄存器), 而且可以使用不同处理器的能力(32-位 和 64-位 体系, 
                        并且也可能是 16 位).</P>
                        <P>内核开发者在移植 x86 代码到新体系时遇到的几个问题与不正确的数据类型相关. 坚持严格的数据类型和使用 
                        -Wall -Wstrict-prototypes 进行编译可能避免大部分的 bug.</P>
                        <P>内核数据使用的数据类型分为 3 个主要类型: 标准 C 类型例如 int, 明确大小的类型例如 u32, 
                        以及用作特定内核对象的类型, 例如 pid_t. 我们将看到这 3 个类型种类应当什么时候以及应当如何使用. 
                        本章的最后的节谈论一些其他的典型问题, 你在移植 x86 的驱动到其他平台时可能遇到的问题, 
                        并且介绍近期内核头文件输出的链表的常用支持.</P>
                        <P>如果你遵照我们提供的指引, 你的驱动应当编译和运行在你无法测试的平台上.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=UseofStandardCTypes.sect></A>11.1.&nbsp;标准 C 
                        类型的使用</H2></DIV></DIV></DIV>
                        <P>尽管大部分程序员习惯自由使用标准类型, 如 int 和 long, 
                        编写设备驱动需要一些小心来避免类型冲突和模糊的 bug.</P>
                        <P>这个问题是你不能使用标准类型, 当你需要"一个 2-字节 填充者"或者"一个东西来代表一个4-字节 
                        字串", 因为正常的 C 数据类型在所有体系上不是相同大小. 为展示各种 C 类型的数据大小, datasize 
                        程序已包含在例子文件 misc-progs 目录中, 由 O' Reilly's FTP 站点提供. 
                        这是一个程序的样例运行, 在一个 i386 系统上(显示的最后 4 个类型在下一章介绍):</P><PRE class=screen>morgana% misc-progs/datasize
arch Size: char short int long ptr long-long u8 u16 u32 u64
i686       1    2     4   4    4   8         1  2   4   8
</PRE>
                        <P>这个程序可以用来显示长整型和指针在 64-位 平台上的不同大小, 如同在不同 Linux 
                        计算机上运行程序所演示的:</P><PRE class=screen>arch  Size:  char  short  int  long  ptr long-long  u8 u16 u32 u64 
i386         1     2      4    4     4   8          1  2   4   8  
alpha        1     2      4    8     8   8          1  2   4   8  
armv4l       1     2      4    4     4   8          1  2   4   8  
ia64         1     2      4    8     8   8          1  2   4   8  
m68k         1     2      4    4     4   8          1  2   4   8  
mips         1     2      4    4     4   8          1  2   4   8  
ppc          1     2      4    4     4   8          1  2   4   8  
sparc        1     2      4    4     4   8          1  2   4   8  
sparc64      1     2      4    4     4   8          1  2   4   8  
x86_64       1     2      4    8     8   8          1  2   4   8  
</PRE>
                        <P>注意有趣的是 SPARC 64 体系在一个 32-位 用户空间运行, 因此那里指针是 32 位宽, 
                        尽管它们在内核空间是 64 位宽. 这可用加载 kdatasize 模块(在例子文件的 misc-modules 
                        目录里)来验证. 这个模块在加载时使用 printk 来报告大小信息, 并且返回一个错误( 因此没有必要卸载它 
                        ):</P><PRE class=screen>kernel: arch Size: char short int long ptr long-long u8 u16 u32 u64
kernel: sparc64    1    2     4   8    8   8         1  2   4   8
</PRE>
                        <P>尽管在混合不同数据类型时你必须小心, 有时有很好的理由这样做. 一种情况是因为内存存取, 
                        与内核相关时是特殊的. 概念上, 尽管地址是指针, 内存管理常常使用一个无符号的整数类型更好地完成; 
                        内核对待物理内存如同一个大数组, 并且内存地址只是一个数组索引. 进一步地, 一个指针容易解引用; 
                        当直接处理内存存取时, 你几乎从不想以这种方式解引用. 使用一个整数类型避免了这种解引用, 因此避免了 bug. 
                        因此, 内核中通常的内存地址常常是 unsigned long, 利用了指针和长整型一直是相同大小的这个事实, 
                        至少在 Linux 目前支持的所有平台上.</P>
                        <P>因为其所值的原因, C99 标准定义了 intptr_t 和 uintptr_t 
                        类型给一个可以持有一个指针值的整型变量. 但是, 这些类型几乎没在 2.6 内核中使用.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=AssigninganExplicitSizetoDataItems.sect></A>11.2.&nbsp;安排一个明确大小给数据项</H2></DIV></DIV></DIV>
                        <P>有时内核代码需要一个特定大小的数据项, 也许要匹配预定义的二进制结构,<SUP>[<A 
                        href="http://www.deansys.com/doc/ldd3/ch11s02.html#ftn.id466598" 
                        name=id466598><FONT color=#0000ff>39</FONT></A>]</SUP> 
                        来和用户空间通讯, 或者来用插入"填充"字段来对齐结构中的数据( 但是关于对齐问题的信息参考 "数据对齐" 一节 
                        ).</P>
                        <P>内核提供了下列数据类型来使用, 无论你什么时候需要知道你的数据的大小. 所有的数据声明在 
                        &lt;asm/types.h&gt;, 它又被 &lt;linux/types.h&gt; 包含.</P><PRE class=programlisting>u8; /* unsigned byte (8 bits) */
u16; /* unsigned word (16 bits) */
u32; /* unsigned 32-bit value */
u64; /* unsigned 64-bit value */
</PRE>
                        <P>存在对应的有符号类型, 但是很少需要; 如果你需要它们, 只要在名子里用 s 代替 u. </P>
                        <P>如果一个用户空间程序需要使用这些类型, 可用使用一个双下划线前缀在名子上: __u8 和其它独立于 
                        __KERNEL__ 定义的类型. 例如, 如果, 一个驱动需要与用户空间中运行的程序交换二进制结构, 通过 
                        ioctl, 头文件应当在结构中声明 32-位 成员为 __u32.</P>
                        <P>重要的是记住这些类型是 Linux 特定的, 并且使用它们妨碍了移植软件到其他的 Unix 口味上. 
                        使用近期编译器的系统支持 C99-标准 类型, 例如 uint8_t 和 uint32_t; 如果考虑到移植性, 
                        使用这些类型比 Linux-特定的变体要好.</P>
                        <P>你可能也注意到有时内核使用传统的类型, 例如 unsigned int, 给那些维数与体系无关的项. 
                        这是为后向兼容而做的. 当 u32 和它的类似物在版本 1.1.67 引入时, 
                        开发者不能改变存在的数据结构为新的类型, 
                        因为编译器发出一个警告当在结构成员和安排给它的值之间有一个类型不匹配时.. Linus 
                        不希望他写给自己使用的操作系统称为多平台的; 结果是, 老的结构有时被松散的键入.</P>
                        <P>事实上, 编译器指示类型不一致, 甚至在 2 个类型只是同一个对象的不同名子, 例如在 PC 上 
                        unsigned long 和 u32.</P>
                        <DIV class=footnotes><BR>
                        <HR align=left width=100>

                        <DIV class=footnote>
                        <P><SUP>[<A 
                        href="http://www.deansys.com/doc/ldd3/ch11s02.html#id466598" 
                        name=ftn.id466598><FONT color=#0000ff>39</FONT></A>] 
                        </SUP>这发生在当读取分区表时, 当执行一个二进制文件时, 或者当解码一个网络报文时.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=InterfaceSpecificTypes.sect></A>11.3.&nbsp;接口特定的类型</H2></DIV></DIV></DIV>
                        <P>内核中一些通常使用的数据类型有它们自己的 typedef 语句, 因此阻止了任何移植性问题. 例如, 
                        一个进程标识符 ( pid ) 常常是 pid_t 而不是 int. 使用 pid_t 
                        屏蔽了任何在实际数据类型上的不同. 我们使用接口特定的表达式来指一个类型, 由一个库定义的, 
                        以便于提供一个接口给一个特定的数据结构.</P>
                        <P>注意, 在近期, 已经相对少定义新的接口特定类型. 使用 typedef 语句已经有许多内核开发者不喜欢, 
                        它们宁愿看到代码中直接使用的真实类型信息, 不是藏在一个用户定义的类型后面. 
                        很多老的接口特定的类型在内核中保留, 但是, 并且它们不会很快消失.</P>
                        <P>甚至当没有定义接口特定的类型, 以和内核其他部分保持一致的方式使用正确的数据类型是一直重要的. 
                        一个嘀哒计数, 例如, 一直是 unsigned long, 独立于它实际的大小, 因此 unsigned 
                        long 类型应当在使用 jiffy 时一直使用. 本节我们集中于 _t 类型的使用.</P>
                        <P>很多 _t 类型在 &lt;linux/types.h&gt; 中定义, 但是列出来是很少有用. 
                        当你需要一个特定类型, 你会在你需要调用的函数的原型中发现它, 或者在你使用的数据结构中.</P>
                        <P>无论何时你的驱动使用需要这样"定制"类型的函数并且你不遵照惯例, 编译器发出一个警告; 如果你使用 
                        -Wall 编译器标志并且小心去除所有的警告, 你能有信心你的代码是可移植的.</P>
                        <P>_t 数据项的主要问题是当你需要打印它们时, 常常不容易选择正确的 printk 或 printf 格式, 
                        你在一个体系上出现的警告会在另一个上重新出现. 例如, 你如何打印一个 size_t, 它在一些平台上是 
                        unsigned long 而在其他某个上面是 unsigned int?</P>
                        <P>无论何时你需要打印某个接口特定的数据, 最好的方法是转换它的值为最大的可能类型(常常是 long 或者 
                        unsigned long ) 并且接着打印它通过对应的格式. 这种调整不会产生错误或者警告, 
                        因为格式匹配类型, 并且你不会丢失数据位, 
因为这个转换或者是一个空操作或者是数据项向更大数据类型的扩展.</P>
                        <P>实际上, 我们在谈论的数据项不会常常要打印的, 因此这个问题只适用于调试信息. 常常, 
                        代码只需要存储和比较接口特定的类型, 加上传递它们作为给库或者内核函数的参数.</P>
                        <P>尽管 _t 类型是大部分情况的正确解决方法, 有时正确的类型不存取. 
                        这发生在某些还未被清理的老接口.</P>
                        <P>我们在内核头文件中发现的一个模糊之处是用在 I/O 函数的数据类型, 它松散地定义( 看第 9 
                        章"平台相关性" 一节 ). 松散的类型在那里主要是因为历史原因, 但是在写代码时它可能产生问题. 例如, 
                        交换给函数如 outb 的参数可能会有麻烦; 如果有一个 port_t 类型, 编译器会发现这个类型.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=OtherPortabilityIssues.sect></A>11.4.&nbsp;其他移植性问题</H2></DIV></DIV></DIV>
                        <P>除了数据类型, 当编写一个驱动时有几个其他的软件问题要记住, 如果你想在 Linux 
平台间可移植.</P>
                        <P>一个通常的规则是怀疑显式的常量值. 常常通过使用预处理宏, 代码已被参数化. 
                        这一节列出了最重要的可移植性问题. 无论何时你遇到已被参数化的值, 
                        你可以在头文件中以及在随官方内核发布的设备驱动中找到提示.</P>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=TimeIntervals.sect></A>11.4.1.&nbsp;时间间隔</H3></DIV></DIV></DIV>
                        <P>当涉及时间间隔, 不要假定每秒有 1000 个嘀哒. 尽管当前对 i386 体系是真实的, 不是每个 
                        Linux 平台都以这个速度运行. 对于 x86 如果你使用 HZ 值(如同某些人做的那样), 
                        这个假设可能是错的, 并且没人知道将来内核会发生什么. 无论何时你使用嘀哒来计算时间间隔, 使用 HZ ( 
                        每秒的定时器中断数 ) 来标定你的时间. 例如, 检查一个半秒的超时, 用 HZ/2 和逝去时间比较. 
                        更普遍地, msec 毫秒对应地嘀哒数一直是 msec*HZ/1000.</P></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=PageSize.sect></A>11.4.2.&nbsp;页大小</H3></DIV></DIV></DIV>
                        <P>当使用内存时, 记住一个内存页是 PAGE_SIZE 字节, 不是 4KB. 假定页大小是 4KB 
                        并且硬编码这个值是一个 PC 程序员常见的错误, 相反, 被支持的平台显示页大小从 4 KB 到 64 KB, 
                        并且有时它们在相同平台上的不同的实现上不同. 相关的宏定义是 PAGE_SIZE 和 PAGE_SHIT. 
                        后者包含将一个地址移位来获得它的页号的位数. 对于 4KB 或者更大的页这个数当前是 12 或者更大. 宏在 
                        &lt;asm/page.h&gt; 中定义; 用户空间程序可以使用 getpagesize 库函数, 
                        如果它们需要这个信息.</P>
                        <P>让我们看一下非一般的情况. 如果一个驱动需要 16 KB 来暂存数据, 它不应当指定一个 2 的指数 给 
                        get_free_pages. 你需要一个可移植解决方法. 这样的解决方法, 幸运的是, 
                        已经由内核开发者写好并且称为 get_order:</P><PRE class=programlisting>#include &lt;asm/page.h&gt;
int order = get_order(16*1024);
buf = get_free_pages(GFP_KERNEL, order);
</PRE>
                        <P>记住, get_order 的参数必须是 2 的幂.</P></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=ByteOrder.sect></A>11.4.3.&nbsp;字节序</H3></DIV></DIV></DIV>
                        <P>小心不要假设字节序. PC 存储多字节值是低字节为先(小端为先, 因此是小端), 
                        一些高级的平台以另一种方式(大端)工作. 任何可能的时候, 你的代码应当这样来编写, 
                        它不在乎它操作的数据的字节序. 但是, 有时候一个驱动需要使用单个字节建立一个整型数或者相反, 
                        或者它必须与一个要求一个特定顺序的设备通讯.</P>
                        <P>包含文件 &lt;asm/byteorder.h&gt; 定义了或者 __BIG_ENDIAN 或者 
                        __LITTLE_ENDIAN, 依赖处理器的字节序. 当处理字节序问题时, 你可能编码一堆 #ifdef 
                        __LITTTLE_ENDIAN 条件语句, 但是有一个更好的方法. Linux 
                        内核定义了一套宏定义来处理之间的转换, 在处理器字节序和你需要以特定字节序存储和加载的数据之间. 例如:</P><PRE class=programlisting>u32 cpu_to_le32 (u32);
u32 le32_to_cpu (u32);
</PRE>
                        <P>这 2 个宏定义转换一个值, 从无论 CPU 使用的什么到一个无符号的, 小端, 32 位数, 
                        并且转换回. 它们不管你的 CPU 是小端还是大端, 不管它是不是 32-位 处理器. 
                        在没有事情要做的情况下它们原样返回它们的参数. 使用这些宏定义易于编写可移植的代码, 
                        而不必使用大量的条件编译建造.</P>
                        <P>有很多类似的函数; 你可以在 &lt;linux/byteorder/big_endian.h&gt; 和 
                        &lt;linux/byteorder/little_endian.h&gt; 中见到完整列表. 一会儿之后, 
                        这个模式不难遵循. be64_to_cpu 转换一个无符号的, 大端, 64-位 值到一个内部 CPU 表示. 
                        le16_to_cpus, 相反, 处理有符号的, 小端, 16 位数. 当处理指针时, 你也会使用如 
                        cpu_to_le32p, 它使用指向一个值的指针来转换, 而不是这个值自身. 
                        剩下的看包含文件.</P></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=DataAlignment.sect></A>11.4.4.&nbsp;数据对齐</H3></DIV></DIV></DIV>
                        <P>编写可移植代码而值得考虑的最后一个问题是如何存取不对齐的数据 -- 例如, 如何读取一个存储于一个不是 4 
                        字节倍数的地址的4字节值. i386 用户常常存取不对齐数据项, 但是不是所有的体系允许这个. 
                        很多现代的体系产生一个异常, 每次程序试图不对齐数据传送时; 数据传输由异常处理来处理, 带来很大的性能牺牲. 
                        如果你需要存取不对齐的数据, 你应当使用下列宏:</P><PRE class=programlisting>#include &lt;asm/unaligned.h&gt;
get_unaligned(ptr);
put_unaligned(val, ptr);
</PRE>
                        <P>这些宏是无类型的, 并且用在每个数据项, 不管它是 1 个, 2 个, 4 个, 或者 8 个字节长. 
                        它们在任何内核版本中定义.</P>
                        <P>关于对齐的另一个问题是跨平台的数据结构移植性. 同样的数据结构( 在 C-语言 源文件中定义 
                        )可能在不同的平台上不同地编译. 编译器根据各个平台不同的惯例来安排结构成员对齐.</P>
                        <P>为了编写可以跨体系移动的数据使用的数据结构, 你应当一直强制自然的数据项对齐, 
                        加上对一个特定对齐方式的标准化. 自然对齐意味着存储数据项在是它的大小的整数倍的地址上(例如, 8-byte 
                        项在 8 的整数倍的地址上). 为强制自然对齐在阻止编译器以不希望的方式安排成员量的时候, 
                        你应当使用填充者成员来避免在数据结构中留下空洞.</P>
                        <P>为展示编译器如何强制对齐, dataalign 程序在源码的 misc-progs 目录中发布, 
                        并且一个对等的 kdataalign 模块是 misc-modules 的一部分. 
                        这是程序在几个平台上的输出以及模块在 SPARC64 的输出:</P><PRE class=screen>arch Align: char short int long ptr long-long u8 u16 u32 u64
i386        1    2     4   4    4   4         1  2   4   4
i686        1    2     4   4    4   4         1  2   4   4
alpha       1    2     4   8    8   8         1  2   4   8
armv4l      1    2     4   4    4   4         1  2   4   4
ia64        1    2     4   8    8   8         1  2   4   8
mips        1    2     4   4    4   8         1  2   4   8
ppc         1    2     4   4    4   8         1  2   4   8
sparc       1    2     4   4    4   8         1  2   4   8
sparc64     1    2     4   4    4   8         1  2   4   8
x86_64      1    2     4   8    8   8         1  2   4   8

kernel: arch Align: char short int long ptr long-long u8 u16 u32 u64
kernel: sparc64     1    2     4   8    8   8         1  2   4   8
</PRE>
                        <P>有趣的是注意不是所有的平台对齐 64-位值在 64-位边界上, 
                        因此你需要填充者成员来强制对齐和保证可移植性.</P>
                        <P>最后, 要知道编译器可能自己悄悄地插入填充到结构中来保证每个成员是对齐的, 为了目标处理器的良好性能. 
                        如果你定义一个结构打算来匹配一个设备期望的结构, 这个自动的填充可能妨碍你的企图. 
                        解决这个问题的方法是告诉编译器这个结构必须是"紧凑的", 不能增加填充者. 例如, 内核头文件 
                        &lt;linux/edd.h&gt; 定义几个与 x86 BIOS 接口的数据结构, 
                        并且它包含下列的定义:</P><PRE class=programlisting>struct
{
        u16 id;
        u64 lun;
        u16 reserved1;
        u32 reserved2;
}
__attribute__ ((packed)) scsi;
</PRE>
                        <P>如果没有 __attribute__ ((packed)), lun 成员可能被在前面添加 2 
                        个填充者字节或者 6 个, 如果我们在 64-位平台上编译这个结构.</P></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=PointersandErrorValues.sect></A>11.4.5.&nbsp;指针和错误值</H3></DIV></DIV></DIV>
                        <P>很多内部内核函数返回一个指针值给调用者. 许多这些函数也可能失败. 大部分情况, 失败由返回一个 NULL 
                        指针值来指示. 这个技术是能用的, 但是它不能通知问题的确切特性. 
                        一些接口确实需要返回一个实际的错误码以便于调用者能够基于实际上什么出错来作出正确的判断.</P>
                        <P>许多内核接口通过在指针值中对错误值编码来返回这个信息. 这样的信息必须小心使用, 
                        因为它们的返回值不能简单地与 NULL 比较. 为帮助创建和使用这类接口, 一小部分函数已可用( 在 
                        &lt;linux/err.h&gt;).</P>
                        <P>一个返回指针类型的函数可以返回一个错误值, 使用:</P><PRE class=programlisting>void *ERR_PTR(long error);
</PRE>
                        <P>这里, error 是常见的负值错误码. 调用者可用使用 IS_ERR 
                        来测试是否一个返回的指针是不是一个错误码:</P><PRE class=programlisting>long IS_ERR(const void *ptr); 
</PRE>
                        <P>如果你需要实际的错误码, 它可能被抽取到, 使用:</P><PRE class=programlisting>long PTR_ERR(const void *ptr); 
</PRE>
                        <P>你应当只对 IS_ERR 返回一个真值的值使用 PTR_ERR; 任何其他的值是一个有效的指针.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=LinkedLists.sect></A>11.5.&nbsp;链表</H2></DIV></DIV></DIV>
                        <P>操作系统内核, 如同其他程序, 常常需要维护数据结构的列表. 有时, Linux 
                        内核已经同时有几个列表实现. 为减少复制代码的数量, 内核开发者已经创建了一个标准环形的, 双链表; 
                        鼓励需要操作列表的人使用这个设施.</P>
                        <P>当使用链表接口时, 你应当一直记住列表函数不做加锁. 如果你的驱动可能试图对同一个列表并发操作, 
                        你有责任实现一个加锁方案. 可选项( 破坏的列表结构, 数据丢失, 内核崩溃) 肯定是难以诊断的.</P>
                        <P>为使用列表机制, 你的驱动必须包含文件 &lt;linux/list.h&gt;. 
                        这个文件定义了一个简单的类型 list_head 结构:</P><PRE class=programlisting>struct list_head { struct list_head *next, *prev; }; 
</PRE>
                        <P>真实代码中使用的链表几乎是不变地由几个结构类型组成, 每一个描述一个链表中的入口项. 为在你的代码中使用 
                        Linux 列表, 你只需要嵌入一个 list_head 在构成这个链表的结构里面. 假设, 
                        如果你的驱动维护一个列表, 它的声明可能看起来象这样:</P><PRE class=programlisting>struct todo_struct
{
        struct list_head list;
        int priority; /* driver specific */
        /* ... add other driver-specific fields */
};
</PRE>
                        <P>列表的头常常是一个独立的 list_head 结构. 图<A 
                        title=图&nbsp;11.1.&nbsp;链表头数据结构 
                        href="http://www.deansys.com/doc/ldd3/ch11s05.html#ldd3-11-1.fig"><FONT 
                        color=#0000ff>链表头数据结构</FONT></A>显示了这个简单的 struct 
                        list_head 是如何用来维护一个数据结构的列表的.</P>
                        <DIV class=figure><A name=ldd3-11-1.fig></A>
                        <P class=title><B>图&nbsp;11.1.&nbsp;链表头数据结构</B></P>
                        <DIV><IMG alt=链表头数据结构 
                        src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/ldd3-11-1.png"></DIV></DIV>
                        <P>链表头必须在使用前用 INIT_LIST_HEAD 宏来初始化. 
                        一个"要做的事情"的链表头可能声明并且初始化用:</P><PRE class=programlisting>struct list_head todo_list; 
INIT_LIST_HEAD(&amp;todo_list); 
&lt;para&gt;可选地, 链表可在编译时初始化:&lt;/para&gt;
LIST_HEAD(todo_list); 
</PRE>
                        <P>几个使用链表的函数定义在 &lt;linux/list.h&gt;:</P>
                        <DIV class=variablelist>
                        <DL>
                          <DT><SPAN class=term><SPAN>list_add(struct list_head 
                          *new, struct list_head *head);</SPAN></SPAN> 
                          <DD>
                          <P>在紧接着链表 head 后面增加新入口项 -- 正常地在链表的开头. 因此, 它可用来构建堆栈. 
                          但是, 注意, head 不需要是链表名义上的头; 如果你传递一个 list_head 结构, 
                          它在链表某处的中间, 新的项紧靠在它后面. 因为 Linux 链表是环形的, 
                          链表的头通常和任何其他的项没有区别.</P>
                          <DT><SPAN class=term><SPAN>list_add_tail(struct 
                          list_head *new, struct list_head *head);</SPAN></SPAN> 

                          <DD>
                          <P>刚好在给定链表头前面增加一个新入口项 -- 在链表的尾部, 换句话说. list_add_tail 
                          能够, 因此, 用来构建先入先出队列.</P>
                          <DT><SPAN class=term><SPAN>list_del(struct list_head 
                          *entry);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_del_init(struct 
                          list_head *entry);</SPAN></SPAN> 
                          <DD>
                          <P>给定的项从队列中去除. 如果入口项可能注册在另外的链表中, 你应当使用 list_del_init, 
                          它重新初始化这个链表指针.</P>
                          <DT><SPAN class=term><SPAN>list_move(struct list_head 
                          *entry, struct list_head *head);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_move_tail(struct 
                          list_head *entry, struct list_head 
                          *head);</SPAN></SPAN> 
                          <DD>
                          <P>给定的入口项从它当前的链表里去除并且增加到 head 的开始. 为安放入口项在新链表的末尾, 使用 
                          list_move_tail 代替.</P>
                          <DT><SPAN class=term><SPAN>list_empty(struct list_head 
                          *head);</SPAN></SPAN> 
                          <DD>
                          <P>如果给定链表是空, 返回一个非零值.</P>
                          <DT><SPAN class=term><SPAN>list_splice(struct 
                          list_head *list, struct list_head 
                          *head);</SPAN></SPAN> 
                          <DD>
                          <P>将 list 紧接在 head 之后来连接 2 个链表.</P></DD></DL></DIV>
                        <P>list_head 结构对于实现一个相似结构的链表是好的, 但是调用程序常常感兴趣更大的结构, 
                        它组成链表作为一个整体. 一个宏定义, list_entry, 映射一个 list_head 
                        结构指针到一个指向包含它的结构的指针. 它如下被调用:</P><PRE class=programlisting>list_entry(struct list_head *ptr, type_of_struct, field_name); 
</PRE>
                        <P>这里 ptr 是一个指向使用的 struct list_head 的指针, type_of_struct 
                        是包含 ptr 的结构的类型, field_name 是结构中列表成员的名子. 在我们之前的 
                        todo_struct 结构中, 链表成员称为简单列表. 因此, 我们应当转变一个列表入口项为它的包含结构, 
                        使用这样一行:</P><PRE class=programlisting>struct todo_struct *todo_ptr = list_entry(listptr, struct todo_struct, list); 
</PRE>
                        <P>list_entry 宏定义使用了一些习惯的东西但是不难用.</P>
                        <P>链表的遍历是容易的: 只要跟随 prev 和 next 指针. 作为一个例子, 假设我们想保持 
                        todo_struct 项的列表已降序的优先级顺序排列. 一个函数来添加新项应当看来如此:</P><PRE class=programlisting>void todo_add_entry(struct todo_struct *new)
{
        struct list_head *ptr;
        struct todo_struct *entry;

        for (ptr = todo_list.next; ptr != &amp;todo_list; ptr = ptr-&gt;next)
        {
                entry = list_entry(ptr, struct todo_struct, list);
                if (entry-&gt;priority &lt; new-&gt;priority) {

                        list_add_tail(&amp;new-&gt;list, ptr);
                        return;
                }
        }
        list_add_tail(&amp;new-&gt;list, &amp;todo_struct)

}
</PRE>
                        <P>但是, 作为一个通用的规则, 最好使用一个预定义的宏来创建循环, 它遍历链表. 前一个循环, 例如, 
                        可这样编码:</P><PRE class=programlisting>void todo_add_entry(struct todo_struct *new)
{
        struct list_head *ptr;
        struct todo_struct *entry;

        list_for_each(ptr, &amp;todo_list)
        {
                entry = list_entry(ptr, struct todo_struct, list);
                if (entry-&gt;priority &lt; new-&gt;priority) {

                        list_add_tail(&amp;new-&gt;list, ptr);
                        return;
                }
        }
        list_add_tail(&amp;new-&gt;list, &amp;todo_struct)

}
</PRE>
                        <P>使用提供的宏帮助避免简单的编程错误; 宏的开发者也已做了些努力来保证它们进行正常. 存在几个变体:</P>
                        <DIV class=variablelist>
                        <DL>
                          <DT><SPAN class=term><SPAN>list_for_each(struct 
                          list_head *cursor, struct list_head 
                          *list)</SPAN></SPAN> 
                          <DD>
                          <P>这个宏创建一个 for 循环, 执行一次, cursor 指向链表中的每个连续的入口项. 
                          小心改变列表在遍历它时.</P>
                          <DT><SPAN class=term><SPAN>list_for_each_prev(struct 
                          list_head *cursor, struct list_head 
                          *list)</SPAN></SPAN> 
                          <DD>
                          <P>这个版本后向遍历链表.</P>
                          <DT><SPAN class=term><SPAN>list_for_each_safe(struct 
                          list_head *cursor, struct list_head *next, struct 
                          list_head *list)</SPAN></SPAN> 
                          <DD>
                          <P>如果你的循环可能删除列表中的项, 使用这个版本. 它简单的存储列表 next 中下一个项, 
                          在循环的开始, 因此如果 cursor 指向的入口项被删除, 它不会被搞乱.</P>
                          <DT><SPAN class=term><SPAN>list_for_each_entry(type 
                          *cursor, struct list_head *list, member)</SPAN></SPAN> 

                          <DD>
                          <DT><SPAN 
                          class=term><SPAN>list_for_each_entry_safe(type 
                          *cursor, type *next, struct list_head *list, 
                          member)</SPAN></SPAN> 
                          <DD>
                          <P>这些宏定义减轻了对一个包含给定结构类型的列表的处理. 这里, cursor 
                          是一个指向包含数据类型的指针, member 是包含结构中 list_head 结构的名子. 有了这些宏, 
                          没有必要安放 list_entry 调用在循环里了.</P></DD></DL></DIV>
                        <P>如果你查看 &lt;linux/list.h&gt; 里面, 你看到有一些附加的声明. hlist 
                        类型是一个有一个单独的, 单指针列表头类型的双向链表; 它常用作创建哈希表和类型结构. 还有宏用来遍历 2 
                        种列表类型, 打算作使用 读取-拷贝-更新 机制(在第 5 章的"读取-拷贝-更新"一节中描述 ). 
                        这些原语在设备驱动中不可能有用; 看头文件如果你愿意知道更多信息关于它们是如何工作的.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=DataTypesinKernel.qr></A>11.6.&nbsp;快速参考</H2></DIV></DIV></DIV>
                        <P>下列符号在本章中介绍了:</P>
                        <DIV class=variablelist>
                        <DL>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;linux/types.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>typedef u8;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>typedef u16;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>typedef u32;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>typedef u64;</SPAN></SPAN> 
                          <DD>
                          <P>保证是 8-位, 16-位, 32-位 和64-位 无符号整型值的类型. 对等的有符号类型也存在. 
                          在用户空间, 你可用 __u8, __u16, 等等来引用这些类型.</P>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;asm/page.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>PAGE_SIZE</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>PAGE_SHIFT</SPAN></SPAN> 
                          <DD>
                          <P>给当前体系定义每页的字节数, 以及页偏移的位数( 对于 4 KB 页是 12, 8 KB 是 13 
                          )的符号.</P>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;asm/byteorder.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN 
                          class=term><SPAN>__LITTLE_ENDIAN</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>__BIG_ENDIAN </SPAN></SPAN>
                          <DD>
                          <P>这 2 个符号只有一个定义, 依赖体系.</P>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;asm/byteorder.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>u32 __cpu_to_le32 
                          (u32);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>u32 __le32_to_cpu 
                          (u32);</SPAN></SPAN> 
                          <DD>
                          <P>在已知字节序和处理器字节序之间转换的函数. 有超过 60 个这样的函数: 在 
                          include/linux/byteorder/ 中的各种文件有完整的列表和它们以何种方式定义.</P>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;asm/unaligned.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN 
                          class=term><SPAN>get_unaligned(ptr);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>put_unaligned(val, 
                          ptr);</SPAN></SPAN> 
                          <DD>
                          <P>一些体系需要使用这些宏保护不对齐的数据存取. 这些宏定义扩展成通常的指针解引用, 
                          为那些允许你存取不对齐数据的体系.</P>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;linux/err.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>void *ERR_PTR(long 
                          error);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>long PTR_ERR(const void 
                          *ptr);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>long IS_ERR(const void 
                          *ptr);</SPAN></SPAN> 
                          <DD>
                          <P>允许错误码由返回指针值的函数返回.</P>
                          <DT><SPAN class=term><SPAN>#include 
                          &lt;linux/list.h&gt;</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_add(struct list_head 
                          *new, struct list_head *head);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_add_tail(struct 
                          list_head *new, struct list_head *head);</SPAN></SPAN> 

                          <DD>
                          <DT><SPAN class=term><SPAN>list_del(struct list_head 
                          *entry);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_del_init(struct 
                          list_head *entry);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_empty(struct list_head 
                          *head);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_entry(entry, type, 
                          member);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_move(struct list_head 
                          *entry, struct list_head *head);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_move_tail(struct 
                          list_head *entry, struct list_head 
                          *head);</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_splice(struct 
                          list_head *list, struct list_head 
                          *head);</SPAN></SPAN> 
                          <DD>
                          <P>操作环形, 双向链表的函数.</P>
                          <DT><SPAN class=term><SPAN>list_for_each(struct 
                          list_head *cursor, struct list_head 
                          *list)</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_for_each_prev(struct 
                          list_head *cursor, struct list_head 
                          *list)</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_for_each_safe(struct 
                          list_head *cursor, struct list_head *next, struct 
                          list_head *list)</SPAN></SPAN> 
                          <DD>
                          <DT><SPAN class=term><SPAN>list_for_each_entry(type 
                          *cursor, struct list_head *list, member)</SPAN></SPAN> 

                          <DD>
                          <DT><SPAN 
                          class=term><SPAN>list_for_each_entry_safe(type 
                          *cursor, type *next struct list_head *list, 
                          member)</SPAN></SPAN> 
                          <DD>
                          <P>方便的宏定义, 
                        用在遍历链表上.</P></DD></DL></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV>
                        <DIV></DIV></DIV></TD></TR></TBODY></TABLE>
                  <P style="MARGIN: 5px; LINE-HEIGHT: 150%"><A 
                  href="http://blog.chinaunix.net/u2/78225/showart.php?id=1270012" 
                  target=_blank>回目录 Linux Device Driver书籍</A> </P></TD></TR>
              <TR>
                <TD align=middle height=25><FONT color=#295200>发表于： 2008-09-28 
                  ，修改于： 2008-10-06 16:36，已浏览64次，有评论0条</FONT> <A id=star 
                  title=推荐这篇文章 onclick="NewWindows(this.href);return false;" 
                  href="http://blog.chinaunix.net/u2/star.php?blogid=78225&amp;artid=1270138">推荐</A> 
                  <A id=complaint title=投诉这篇文章 
                  onclick="NewWindows(this.href);return false;" 
                  href="http://blog.chinaunix.net/u2/complaint.php?blogid=78225&amp;artid=1270138">投诉</A> 
                </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
    <TD width=18 
    background="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_right.gif"></TD></TR>
  <TR>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_left_bottom.gif" 
      border=0></TD>
    <TD 
    background="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_bottom.gif">
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"></P></TD>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/bg_art_right_bottom.gif" 
      border=0></TD></TR></TBODY></TABLE><BR>
<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#a5bd6b cellSpacing=1 
cellPadding=0 width="90%" align=center border=1>
  <TBODY>
  <TR>
    <TD style="COLOR: #295200" bgColor=#eff7de height=25><B>网友评论</B></TD></TR>
  <TR>
    <TD bgColor=#ffffff height=1></TD></TR>
  <TR>
    <TD align=middle bgColor=#f9f5e7>
      <TABLE 
      style="COLOR: #295200; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word" 
      cellSpacing=0 cellPadding=0 width="100%" align=center border=0>
        <TBODY></TBODY></TABLE></TD></TR></TBODY></TABLE><BR>
<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#a5bd6b cellSpacing=1 
cellPadding=0 width="90%" align=center border=1>
  <TBODY>
  <TR>
    <TD style="COLOR: #295200" bgColor=#eff7de height=25><B>发表评论</B></TD></TR>
  <TR>
    <TD bgColor=#ffffff height=1></TD></TR>
  <TR>
    <TD align=middle bgColor=#f9f5e7><IFRAME name=comment 
      src="Linux Device Driver书籍（11）内核中的数据类型 - LDD3 - 嵌入式驱动进行时.files/comment.htm" 
      frameBorder=0 width="100%" 
height=160></IFRAME></TD></TR></TBODY></TABLE></BODY></HTML>
