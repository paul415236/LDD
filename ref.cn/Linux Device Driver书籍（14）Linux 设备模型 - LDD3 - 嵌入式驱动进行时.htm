<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0057)http://blog.chinaunix.net/u2/78225/showart.php?id=1270149 -->
<HTML><HEAD><TITLE>Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时</TITLE>
<META http-equiv=Content-Type content="text/html; charset=gbk"><LINK 
href="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/index.css" 
rel=stylesheet></LINK><LINK title="ChinaUnix Blog RSS Feed" 
href="http://blog.chinaunix.net/u/rss.php?id=78225" type=application/rss+xml 
rel=alternate></LINK>
<META content="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时" 
name=keywords>
<META 
content="中国最大的IT技术博客-ChinaUnix博客：Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时" 
name=description>
<META content="MSHTML 6.00.2900.3243" name=GENERATOR></HEAD>
<BODY style="BACKGROUND: #ffffff" leftMargin=0 topMargin=0 align="center" 
marginheight="0" marginwidth="0">
<TABLE style="BORDER-COLLAPSE: collapse; HEIGHT: 25px" height=25 cellSpacing=0 
cellPadding=0 width="100%" align=center 
background="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/tophem1.gif" 
border=0>
  <TBODY>
  <TR>
    <TD id=tool-bar noWrap align=left>&nbsp; <A 
      href="http://blog.chinaunix.net/" target=_blank>博客首页</A> <A 
      href="http://blog.chinaunix.net/register.php" target=_blank>注册</A> <A 
      href="http://bbs.chinaunix.net/forumdisplay.php?fid=51" 
      target=_blank>建议与交流</A> <A href="http://blog.chinaunix.net/top/" 
      target=_blank>排行榜</A> <A 
      onclick="NewWindows('http://www.cublog.cn/addlink.php?url='+location.href+'&amp;title='+document.title);return false;" 
      href="http://blog.chinaunix.net/u2/78225/" target=_blank>加入友情链接</A> </TD>
    <FORM id=loginForm action=/search.php method=get target=_blank>
    <TD noWrap align=right><IMG id=starimg height=12 alt="" 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/userstar.gif" 
      width=55 border=0> <A id=star title=给此博客推荐值 
      onclick="NewWindows(this.href);return false;" 
      href="http://blog.chinaunix.net/u2/star.php?blogid=78225">推荐</A> <A 
      id=complaint title=投诉此博客 onclick="NewWindows(this.href);return false;" 
      href="http://blog.chinaunix.net/u2/complaint.php?blogid=78225">投诉</A> 
      搜索：<INPUT name=q> <INPUT class=button1 type=submit value=搜索> <A 
      href="http://blog.chinaunix.net/help/">帮助</A></TD></FORM></TR></TBODY></TABLE>
<SCRIPT language=javascript>
<!--

navHover = function() {
var lis = document.getElementById("navmenu").getElementsByTagName("LI");
for (var i=0; i<lis.length; i++) {
lis[i].onmouseover=function() {
this.className+=" iehover";
}
lis[i].onmouseout=function() {
this.className=this.className.replace(new RegExp(" iehover\\b"), "");
}
}
}

function NewWindows(shref){
var xx=(window.screen.width-450)/2;
var yy=(window.screen.height-200)/2;
pp=window.open(shref,"win","menubar=no,location=no,resizable=no,scrollbars=no,status=no,left="+xx+",top="+yy+",Width=450,Height=200");
}
function $(s){return document.getElementById(s);}
//-->
</SCRIPT>

<TABLE 
style="BACKGROUND-IMAGE: url(http://www.cublog.cn/templates/newgreen/images/bg_top.gif); BACKGROUND-REPEAT: no-repeat; BORDER-COLLAPSE: collapse" 
height=143 cellSpacing=0 cellPadding=0 width="100%" align=center bgColor=#187218 
border=0>
  <TBODY>
  <TR>
    <TD width=360></TD>
    <TD align=middle width=500>
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"><FONT style="FONT-SIZE: 14pt" 
      color=#ffffff><B>
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"><FONT style="FONT-SIZE: 14px" 
      color=#ffffff><B>嵌入式驱动进行时 </B></FONT></P></B></FONT>
      <P></P></TD>
    <TD width=360>学习学习再学习！</TD></TR>
  <TR>
    <TD colSpan=3>
      <TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
      cellPadding=0 width=980 border=0>
        <TBODY>
        <TR>
          <TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<TABLE style="BORDER-COLLAPSE: collapse" height=27 cellSpacing=0 cellPadding=0 
width="100%" align=center bgColor=#ffffff 
background="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_menu.gif" 
border=0>
  <TBODY>
  <TR>
    <TD align=middle width=30><IMG height=29 alt="" 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/img_menu_left.gif" 
      width=26 border=0></TD>
    <TD width=200><A class=list1 href="http://yuchuan2008.cublog.cn/" 
      target=_blank>yuchuan2008.cublog.cn</A> </TD>
    <TD style="COLOR: #2a5200" align=right width=750>
      <UL id=navmenu>
        <LI class=ul0><A class=list1 href="http://control.cublog.cn/" 
        target=_blank>管理博客</A> </LI>
        <LI class=ul0><A class=list1 
        href="http://control.cublog.cn/article_new.php" target=_blank>发表文章</A> 
        </LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/guestbook.html">留言</A> </LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/links.html">收藏夹</A> 
        <!-- 0 --></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/group.html">博客圈</A> </LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/music.html">音乐</A> 
        <!-- 0 --></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/photo.html">相册</A> 
        <!-- 0 --></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/article.html">文章</A> 
        <UL class=ul1>
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96075.html">・ 
          Bootloader（转载）<!-- a96075 --></A><!-- 96075 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95828.html">・ 
          嵌入式C语言基础（转载）<!-- a95828 --></A><!-- 95828 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95774.html">・ 
          Linux设备驱动（转载）&nbsp;&nbsp;&nbsp;<FONT face="Wingdings 3">}</FONT></A>
          <UL class=ul2>
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96083.html">・ LDD3<!-- a96083 --></A><!-- 96083 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96060.html">・ 
            Linux设备驱动理论<!-- a96060 --></A><!-- 96060 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95966.html">・ 
            Linux字符设备驱动<!-- a95966 --></A><!-- 95966 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95967.html">・ 
            Linux块设备驱动<!-- a95967 --></A><!-- 95967 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95969.html">・ 
            Linux总线驱动<!-- a95969 --></A><!-- 95969 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_95968.html">・ 
            Linux网络设备驱动<!-- a95968 --></A><!-- 95968 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96065.html">・ 
            Linux复杂设备驱动<!-- a96065 --></A><!-- 96065 --> </LI></UL>
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96073.html">・ 
          Linux内核（转载）<!-- a96073 --></A><!-- 96073 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96055.html">・ 
          学习&amp;&amp;工作&nbsp;&nbsp;&nbsp;<FONT face="Wingdings 3">}</FONT></A>
          <UL class=ul2>
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96507.html">・ 
            嵌入式系统开发<!-- a96507 --></A><!-- 96507 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96918.html">・ 
            Embest 2410<!-- a96918 --></A><!-- 96918 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96639.html">・ 
            LINUX下C应用编程<!-- a96639 --></A><!-- 96639 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96508.html">・ 
            Linux驱动开发<!-- a96508 --></A><!-- 96508 --> 
            <LI><A 
            href="http://blog.chinaunix.net/u2/78225/article_96509.html">・ 测试技术<!-- a96509 --></A><!-- 96509 --> </LI></UL>
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95777.html">・ 
          交叉编译（转载）<!-- a95777 --></A><!-- 95777 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96080.html">・ 
          ARM技术（转载）<!-- a96080 --></A><!-- 96080 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_97102.html">・ 
          嵌入式系统开发（转载）<!-- a97102 --></A><!-- 97102 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95775.html">・ 
          Linux基础（转载）<!-- a95775 --></A><!-- 95775 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_95854.html">・ 
          Linux应用程序（转载）<!-- a95854 --></A><!-- 95854 --> 
          <LI><A href="http://blog.chinaunix.net/u2/78225/article_96053.html">・ 
          其他<!-- a96053 --></A><!-- 96053 --> </LI></UL></LI>
        <LI class=ul0><A class=list1 
        href="http://blog.chinaunix.net/u2/78225/index.html">首页</A> </LI></UL></TD>
    <TD width=10></TD></TR>
  <TR>
    <TD colSpan=4>
      <TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
      cellPadding=0 width=980 border=0>
        <TBODY>
        <TR>
          <TD></TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<SCRIPT language=javascript>
function $(s){return document.getElementById(s);}
function ShowHideDiv(divid,iImg){
if($(divid).style.display == "none"){
iImg.src="../../templates/newgreen/images/dot2.gif";
$(divid).style.display = "block";
iImg.title="收起";
}else{
iImg.src="../../templates/newgreen/images/dot4.gif";
$(divid).style.display = "none";
iImg.title="展开";
}
}
navHover();
</SCRIPT>

<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
cellPadding=0 width="100%" border=0>
  <TBODY>
  <TR>
    <TD height=3></TD></TR></TBODY></TABLE><BR>
<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#111111 cellSpacing=0 
cellPadding=0 width="90%" align=center border=0>
  <TBODY>
  <TR>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_left_top.gif" 
      border=0></TD>
    <TD 
    background="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_top.gif">
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"></P></TD>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_right_top.gif" 
      border=0></TD></TR>
  <TR>
    <TD width=18 
    background="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_left.gif"></TD>
    <TD align=middle bgColor=#f5fdee><BR><FONT style="FONT-SIZE: 14pt" 
      color=#295200><B>Linux Device Driver书籍（14）Linux 设备模型</B></FONT> 
      <TABLE style="BORDER-COLLAPSE: collapse" borderColor=#a5bd6b cellSpacing=1 
      cellPadding=0 width="100%" border=1>
        <TBODY>
        <TR>
          <TD align=middle>
            <TABLE style="BORDER-COLLAPSE: collapse; WORD-WRAP: break-word" 
            cellSpacing=0 cellPadding=0 width="100%" border=0>
              <TBODY>
              <TR>
                <TD align=middle>
                  <TABLE 
                  style="BORDER-COLLAPSE: collapse; WORD-WRAP: break-word" 
                  cellSpacing=0 cellPadding=0 width="100%" border=0>
                    <TBODY>
                    <TR>
                      <TD>
                        <DIV id=art style="MARGIN: 15px">
                        <DIV>第&nbsp;14&nbsp;章&nbsp;Linux 设备模型</DIV>
                        <DIV>
                        <P>在 2.5 开发循环中一个声明的目标是为内核创建一个统一的设备模型. 之前的内核没有单一的数据结构, 
                        使它们可以来获取关于系统如何整合的信息. 尽管缺乏信息, 有时事情也进行的不错. 新系统, 
                        带有它们的更加复杂的技术并且需要支持诸如电源管理等特性, 但是, 
                        清楚地要求需要一个通用的描述系统结构的抽象.</P>
                        <P>2.6 设备模型提供了这个抽象. 现在它用在内核来支持广泛的任务, 包括:</P>
                        <DIV class=variablelist>
                        <DL>
                          <DT><SPAN class=term><SPAN>电源管理和系统关机</SPAN></SPAN> 
                          <DD>
                          <P>这些需要一个对系统的结构的理解. 例如, 一个 USB 宿主适配器不可能被关闭, 
                          在处理所有的连接到这个适配器的设备之前. 这个设备模型使能了一个按照正确顺序的系统硬件的遍历.</P>
                          <DT><SPAN class=term><SPAN>与用户空间的通讯</SPAN></SPAN> 
                          <DD>
                          <P>sysfs 虚拟文件系统的实现被紧密地捆绑进设备模型, 并且暴露它所代表的结构. 
                          关于系统到用户空间的信息提供和改变操作参数的旋纽正越来越多地通过 sysfs 和 
通过设备模型来完成.</P>
                          <DT><SPAN class=term><SPAN>可热插拔设备</SPAN></SPAN> 
                          <DD>
                          <P>计算机硬件正更多地动态变化; 外设可因用户的一时念头而进出. 
                          在内核中使用的来处理和(特别的)与用户空间关于设备插入和拔出的通讯, 是由设备模型来管理.</P>
                          <DT><SPAN class=term><SPAN>设备类别</SPAN></SPAN> 
                          <DD>
                          <P>系统的许多部分对设备如何连接没有兴趣, 但是它们需要知道什么类型的设备可用. 
                          设备模型包括一个机制来分配设备给类别, 它在一个更高的功能性的级别描述了这些设备, 
                          并且允许它们从用户空间被发现.</P>
                          <DT><SPAN class=term><SPAN>对象生命期</SPAN></SPAN> 
                          <DD>
                          <P>许多上面描述的功能, 包括热插拔支持和 sysfs, 使在内核中创建和操作对象复杂了. 
                          设备模型的实现要求创建一套机制来处理对象生命期, 它们之间的关系, 
                        和它们在用户空间的表示.</P></DD></DL></DIV>
                        <P>Linux 设备模型是一个复杂的数据结构. 例如, 考虑图<A 
                        title=图&nbsp;14.1.&nbsp;设备模型的一小部分 
                        href="http://www.deansys.com/doc/ldd3/ch14.html#ldd3-14-1.fig"><FONT 
                        color=#0000ff>设备模型的一小部分</FONT></A>, 它展示了(用简单的形式)和 USB 
                        鼠标关联的设备模型结构的微小片段. 图中心的下方, 我们看到核心"设备"树, 展示了鼠标如何连接到系统. 
                        "bus"树跟踪什么连接到每个总线, 而在"classes" 下的子树涉及设备提供的功能, 
                        不管它们是如何连接的. 设备模型树即便在一个简单的系统中也包含几百个节点, 如同在图中展示的那些; 
                        它是一个难于整个呈现的数据结构.</P>
                        <DIV class=figure><A name=ldd3-14-1.fig></A>
                        <P class=title><B>图&nbsp;14.1.&nbsp;设备模型的一小部分</B></P>
                        <DIV><IMG alt=设备模型的一小部分 
                        src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/ldd3-14-1.png"></DIV></DIV>
                        <P>对大部分, Linux 设备模型代码负责所有这些方面, 而不强加自己于驱动作者之上. 它大部分位于后面; 
                        和设备模型的直接交互通常由总线一级的逻辑和各种其他的内核子系统处理. 结果, 许多驱动作者会完全忽略设备模型, 
                        并且信任它来照顾它自己.</P>
                        <P>有时, 但是, 理解设备模型是一个好事情. 有时设备模型从其他的层后面遛出来; 例如, 通用的 DMA 
                        代码( 我们在第 15 章遇到) 使用 struct device. 你可能想使用一些由设备模型提供的能力, 
                        例如引用计数和由 kobjects 提供的相关特色. 通过 sysfs 和 用户空间的通讯也是一个设备模型功能; 
                        本章解释了这个通讯如何工作.</P>
                        <P>但是, 我们开始于一个自底而上的设备模型的表述. 设备模型的复杂性使得难于从一个高层视角来理解. 
                        我们的希望是, 通过展示低层设备组件如何工作, 我们可为你准备这个挑战, 
                        掌握这些组件如何用来建立更大的结构.</P>
                        <P>对大部分读者, 本章可作为高级材料,不需要在第一次读完. 鼓励那些对 Linux 
                        设备模型如何工作感兴趣的人努力向前, 但是, 在我们进入底层细节时.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=KobjectsKsetsandSubsystems.sect></A>14.1.&nbsp;Kobjects, 
                        Ksets 和 Subsystems </H2></DIV></DIV></DIV>
                        <P>Kobject 是基础的结构, 它保持设备模型在一起. 初始地它被作为一个简单的引用计数, 
                        但是它的责任已随时间增长, 并且因此有了它自己的战场. struct kobject 
                        所处理的任务和它的支持代码现在包括:</P>
                        <DIV class=variablelist>
                        <DL>
                          <DT><SPAN class=term><SPAN>对象的引用计数</SPAN></SPAN> 
                          <DD>
                          <P>常常, 当一个内核对象被创建, 没有方法知道它会存在多长时间. 
                          一种跟踪这种对象生命周期的方法是通过引用计数. 当没有内核代码持有对给定对象的引用, 
                          那个对象已经完成了它的有用寿命并且可以被删除.</P>
                          <DT><SPAN class=term><SPAN>sysfs 表示</SPAN></SPAN> 
                          <DD>
                          <P>在 sysfs 中出现的每个对象在它的下面都有一个 kobject, 
                          它和内核交互来创建它的可见表示.</P>
                          <DT><SPAN class=term><SPAN>数据结构粘和</SPAN></SPAN> 
                          <DD>
                          <P>设备模型是, 整体来看, 一个极端复杂的由多级组成的数据结构, 各级之间有许多连接. kobject 
                          实现这个结构并且保持它在一起.</P>
                          <DT><SPAN class=term><SPAN>热插拔事件处理</SPAN></SPAN> 
                          <DD>
                          <P>kobject 子系统处理事件的产生, 
                        事件通知用户空间关于系统中硬件的来去.</P></DD></DL></DIV>
                        <P>你可能从前面的列表总结出 kobject 是一个复杂的结构. 这可能是对的. 通过一次看一部分, 但是, 
                        是有可能理解这个结构和它如何工作的.</P>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=KobjectBasics.sect></A>14.1.1.&nbsp;Kobject 
                        基础</H3></DIV></DIV></DIV>
                        <P>一个 kobject 有类型 struct kobject; 它在 
                        &lt;linux/kobject.h&gt; 中定义. 这个文件还包含许多其他和 kobject 
                        相关的结构的声明, 一个操作它们的函数的长列表.</P>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Embeddingkobjects.sect></A>14.1.1.1.&nbsp;嵌入的 
                        kobjects</H4></DIV></DIV></DIV>
                        <P>在我们进入细节前, 值得花些时间理解如何使用 kobjects. 如果你回看被 kobjects 
                        处理的函数列表, 你会看到它们都是代表其他对象进行的服务. 一个 kobject, 换句话说, 
                        对其自己很少感兴趣; 它存在仅仅为了结合一个高级对象到设备模型.</P>
                        <P>因此, 对于内核代码它很少(甚至不知道)创建一个孤立的 kobject; 相反, kobject 
                        被用来控制存取更大的, 特定域的对象. 为此, kobject 被嵌入到其他结构中. 
                        如果你习惯以面向对象的术语考虑事情, kobject 可被看作一个顶级的, 抽象类, 其他的类自它而来. 一个 
                        kobject 实现一系列功能, 这些功能对自己不是特别有用而对其他对象是好的. C 语言不允许直接表达继承, 
                        因此其他的技术 -- 例如将一个结构嵌入另一个 -- 必须使用.</P>
                        <P>作为一个例子, 让我们回看 struct cdev, 我们在第 3 章遇到过它. 那个结构, 如同在 
                        2.6.10 内核中发现的, 看来如此:</P><PRE class=programlisting>struct cdev {
 struct kobject kobj;
 struct module *owner;
 struct file_operations *ops;
 struct list_head list;
 dev_t dev;
 unsigned int count; 
};
</PRE>
                        <P>我们可以看出, cdev 结构有一个 kobject 嵌在里面. 如果你有一个这样的结构, 
                        会发现它的嵌入的 kobject 只是使用 kobj 成员. 使用 kobjects 的代码有相反的问题, 
                        但是: 如果一个 struct kobject 指针, 什么是指向包含结构的指针? 你应当避免窍门(例如假定 
                        kobject 是在结构的开始), 并且, 相反, 使用 container_of 宏 (在第 3 
                        章的"open 方法"一节中介绍的). 因此转换一个指向嵌在一个结构 cdev 中的一个 struct 
                        kobject 的指针 kp 的方法是:</P><PRE class=programlisting>struct cdev *device = container_of(kp, struct cdev, kobj); 
</PRE>
                        <P>程序员常常定义一个简单的宏来"后向转换" kobject 指针到包含类型.</P></DIV>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Kobjectinitialization.sect></A>14.1.1.2.&nbsp;kobject 
                        初始化</H4></DIV></DIV></DIV>
                        <P>本书已经展示了许多数据类型, 带有简单的在编译或者运行时初始化机制. 一个 kobject 
                        的初始化有些复杂, 特别当使用它的所有函数时. 不管一个 kobject 如何使用, 但是, 
                        必须进行几个步骤.</P>
                        <P>这些步骤的第一个是仅仅设置整个 kobject 为 0, 常常使用一个对 memset 的调用. 
                        常常这个初始化作为清零这个 kobjiect 嵌入的结构的一部分. 清零一个 kobject 
                        失败导致非常奇怪的崩溃, 进一步会掉线; 这不是你想跳过的一步.</P>
                        <P>下一步是设立一些内部成员, 使用对 kobject_init() 的调用:</P><PRE class=programlisting>void kobject_init(struct kobject *kobj); 
</PRE>
                        <P>在其他事情中, kobject_init 设置 kobject 的引用计数为 1. 调用 
                        kobject_init 不够, 但是. kobject 用户必须, 至少, 设置 kobject 的名子. 
                        这是用在 sysfs 入口的名子. 如果你深入内核代码, 你可以发现直接拷贝一个字符串到 kobject 
                        的名子成员的代码, 但是应当避免这个方法. 相反, 使用:</P><PRE class=programlisting>int kobject_set_name(struct kobject *kobj, const char *format, ...); 
</PRE>
                        <P>这个函数采用一个 printk 风格的变量参数列表. 不管你信或不信, 对这种操作实际上可能失败( 
                        他可能试图分配内存 ); 负责任的代码应当检查返回值并且有针对性的相应.</P>
                        <P>其他的由创建者应当设置的 kobject 成员, 直接或间接, 是 ktype, kset, 和 
                        parent. 我们在本章稍后到这些.</P></DIV>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Referencecountmanipulation.sect></A>14.1.1.3.&nbsp;引用计数的操作</H4></DIV></DIV></DIV>
                        <P>一个 kobject 的其中一个关键函数是作为一个引用计数器, 给一个它被嵌入的对象. 
                        只要对这个对象的引用存在, 这个对象( 和支持它的代码) 必须继续存在. 来操作一个 kobject 
                        的引用计数的低级函数是:</P><PRE class=programlisting>struct kobject *kobject_get(struct kobject *kobj);
void kobject_put(struct kobject *kobj);
</PRE>
                        <P>一个对 kobject_get 的成功调用递增 kobject 的 引用计数并且返回一个指向 
                        kobject 的指针. 如果, 但是, 这个 kobject 已经在被销毁的过程中, 这个操作失败, 并且 
                        kobject_get 返回 NULL. 这个返回值必须总是被测试, 
                        否则可能导致无法结束的令人不愉快的竞争情况.</P>
                        <P>当一个引用被释放, 对 kobject_put 的调用递减引用计数, 并且可能地, 释放这个对象. 记住 
                        kobject _init 设置这个引用计数为 1; 因此当你创建一个 kobject, 你应当确保对应地采取 
                        kobject_put 调用, 当这个初始化引用不再需要.</P>
                        <P>注意, 在许多情况下, 在 kobject 自身中的引用计数可能不足以阻止竞争情况. 一个 kobject 
                        的存在( 以及它的包含结构 ) 可能非常, 例如, 需要创建这个 kobject 的模块的继续存在. 在这个 
                        kobject 仍然在被传送时不能卸载那个模块. 这是为什么我们上面看到的 cdev 结构包含一个 struct 
                        module 指针. struct cdev 的引用计数实现如下:</P><PRE class=programlisting>struct kobject *cdev_get(struct cdev *p) 
{
 struct module *owner = p-&gt;owner;
 struct kobject *kobj;
 if (owner &amp;&amp; !try_module_get(owner))
 return NULL;
 kobj = kobject_get(&amp;p-&gt;kobj);
 if (!kobj)
 module_put(owner);
 return kobj;
}
</PRE>
                        <P>创建一个对 cdev 结构的引用还需要创建一个对拥有它的模块的引用. 因此, cdev_get 使用 
                        try_module_get 来试图递增这个模块的使用计数. 如果这个操作成功, kobject_get 
                        被同样用来递增 kobject 的引用计数. 那个操作可能失败, 当然, 因此这个代码检查自 
                        kobject_get 的返回值并且释放它的对模块的引用如果事情没有解决.</P></DIV>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Releasefunctionsandkobjecttypes.sect></A>14.1.1.4.&nbsp;释放函数和 
                        kobject 类型</H4></DIV></DIV></DIV>
                        <P>讨论中仍然缺失的一个重要事情是当一个 kobject 的引用计数到 0 时会发生什么. 创建 
                        kobject 的代码通常不知道什么时候要发生这个情况; 如果它知道, 在第一位使用一个引用计数就没有意义了. 
                        即便当引入 sysfs 时可预测的对象生命周期变得更加复杂; 用户空间程序可保持一个对 kobject 的引用( 
                        通过保持一个它的关联的 sysfs 文件打开 )一段任意的时间.</P>
                        <P>最后的结果是一个被 kobject 保护的结构无法在任何一个单个的, 可预测的驱动生命周期中的点被释放, 
                        但是可以在必须准备在 kobject 的引用计数到 0 的任何时刻运行的代码中. 引用计数不在创建 
                        kobject 的代码的直接控制之下. 因此这个代码必须被异步通知, 无论何时对它的 kobject 
                        的最后引用消失.</P>
                        <P>这个通知由 kobject 的一个释放函数来完成. 常常地, 这个方法有一个形式如下:</P><PRE class=programlisting>void my_object_release(struct kobject *kobj)
{

 struct my_object *mine = container_of(kobj, struct my_object, kobj); 

/* Perform any additional cleanup on this object, then... */
 kfree(mine);
}
</PRE>
                        <P>要强调的重要一点是: 每个 kobject 必须有一个释放函数, 并且这个 kobject 必须持续( 
                        以一致的状态 ) 直到这个方法被调用. 如果这些限制不满足, 代码就有缺陷. 
                        当这个对象还在使用时被释放会有风险, 或者在最后引用被返回后无法释放对象.</P>
                        <P>有趣的是, 释放方法没有存储在 kobject 自身里面; 相反, 它被关联到包含 kobject 
                        的结构类型中. 这个类型被跟踪, 用一个 struct kobj_type 结构类型, 常常简单地称为一个 
                        "ktype". 这个结构看来如下:</P><PRE class=programlisting>struct kobj_type {
 void (*release)(struct kobject *);
 struct sysfs_ops *sysfs_ops;
 struct attribute **default_attrs;
};
</PRE>
                        <P>在 struct kobj_type 中的 release 成员是, 当然, 一个指向这个 kobject 
                        类型的 release 方法的指针. 我们将回到其他 2 个成员( sysfs_ops 和 
                        default_attrs )在本章后面.</P>
                        <P>每一个 kobject 需要有一个关联的 kobj_type 结构. 易混淆地, 指向这个结构的指针能在 
                        2 个不同的地方找到. kobject 结构自身包含一个成员(称为 ktype)包含这个指针. 但是, 如果这个 
                        kobject 是一个 kset 的成员, kobj_type 指针由 kset 提供. ( 我们将在下一节查看 
                        ksets. ) 其间, 这个宏定义:</P><PRE class=programlisting>struct kobj_type *get_ktype(struct kobject *kobj); finds the kobj_type pointer for a given kobject. 
</PRE></DIV></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=KobjectHierachiesKsetsandSubsystems.sect></A>14.1.2.&nbsp;kobject 
                        层次, kset, 和子系统</H3></DIV></DIV></DIV>
                        <P>kobject 结构常常用来连接对象到一个层级的结构中, 匹配正被建模的子系统的结构. 有 2 
                        个分开的机制对于这个连接: parent 指针和 ksets.</P>
                        <P>在结构 kobject 中的 parent 成员是一个指向其他对象的指针 -- 代表在层次中之上的下一级. 
                        如果, 例如, 一个 kobject 表示一个 USB 设备, 它的 parent 指针可能指示这个设备被插入的 
                        hub.</P>
                        <P>parent 指针的主要用途是在 sysfs 层次中定位对象. 我们将看到这个如何工作, 在"低级 
                        sysfs 操作"一节中.</P>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Ksets.sect></A>14.1.2.1.&nbsp;Ksets 
                        对象</H4></DIV></DIV></DIV>
                        <P>很多情况, 一个 kset 看来象一个 kobj_type 结构的扩展; 一个 kset 
                        是一个嵌入到相同类型结构的 kobject 的集合. 但是, 虽然 struct kobj_type 
                        关注的是一个对象的类型, struct kset 被聚合和集合所关注. 这 2 
                        个概念已被分开以至于一致类型的对象可以出现在不同的集合中.</P>
                        <P>因此, 一个 kset 的主要功能是容纳; 它可被当作顶层的给 kobjects 的容器类. 实际上, 
                        每个 kset 在内部容纳它自己的 kobject, 并且它可以, 在许多情况下, 如同一个 kobject 
                        相同的方式被对待. 值得注意的是 ksets 一直在 sysfs 中出现; 一旦一个 kset 
                        已被建立并且加入到系统, 会有一个 sysfs 目录给它. kobjects 没有必要在 sysfs 中出现, 
                        但是每个是 kset 成员的 kobject 都出现在那里.</P>
                        <P>增加一个 kobject 到一个 kset 常常在一个对象创建时完成; 它是一个 2 步的过程. 
                        kobject 的 kset 成员必须 ???; 接着kobject 应当被传递到:</P><PRE class=programlisting>int kobject_add(struct kobject *kobj); 
</PRE>
                        <P>如常, 程序员应当小心这个函数可能失败(在这个情况下它返回一个负错误码)并且相应地反应. 
                        有一个内核提供的方便函数:</P><PRE class=programlisting>extern int kobject_register(struct kobject *kobj); 
</PRE>
                        <P>这个函数仅仅是一个 kobject_init 和 kobject_add 的结合.</P>
                        <P>当一个 kobject 被传递给 kobject_add, 它的引用计数被递增. kset 中容纳的, 
                        毕竟, 是一个对这个对象的引用. 某种意义上, kobject 可能要必须从 kset 中移出来清除这个引用; 
                        完成这个使用:</P><PRE class=programlisting>void kobject_del(struct kobject *kobj); 
</PRE>
                        <P>还有一个 kobject_unregister 函数, 是 kobject_del 和 
                        kobject_put 的结合.</P>
                        <P>一个 kset 保持它的子女在一个标准的内核链表中. 在大部分情况下, 被包含的 kobjects 
                        也有指向这个 kset 的指针( 或者, 严格地, 它的嵌入 kobject)在它们的 parent 的成员. 
                        因此, 典型地, 一个 kset 和它的 kobjects 看来有些象你在图 <A 
                        title="图&nbsp;14.2.&nbsp;一个简单的 kset 层次" 
                        href="http://www.deansys.com/doc/ldd3/ch14.html#ldd3-14-2.fig"><FONT 
                        color=#0000ff>一个简单的 kset 层次</FONT></A>中所见. 记住:</P>
                        <DIV class=figure><A name=ldd3-14-2.fig></A>
                        <P class=title><B>图&nbsp;14.2.&nbsp;一个简单的 kset 
层次</B></P>
                        <DIV><IMG alt="一个简单的 kset 层次" 
                        src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/ldd3-14-2.png"></DIV></DIV>
                        <DIV class=itemizedlist>
                        <UL type=disc>
                          <LI>
                          <P>图表中的所有的被包含的 kobjects 实际上被嵌入在一些其他类型中, 甚至可能其他的 
                          ksets.</P>
                          <LI>
                          <P>一个 kobject 的 parent 不要求是包含 kset( 
                          尽管任何其他的组织可能是奇怪的和稀少的).</P></LI></UL></DIV></DIV>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Operationsonksets.sect></A>14.1.2.2.&nbsp;ksets 
                        之上的操作</H4></DIV></DIV></DIV>
                        <P>对于初始化和设置, ksets 有一个接口非常类似于 kobjects. 下列函数存在:</P><PRE class=programlisting>void kset_init(struct kset *kset);
int kset_add(struct kset *kset);
int kset_register(struct kset *kset);
void kset_unregister(struct kset *kset);
</PRE>
                        <P>对大部分, 这些函数只是在 kset 的嵌入对象上调用类似的 kobject_ 函数.</P>
                        <P>为管理 ksets 的引用计数, 情况大概相同:</P><PRE class=programlisting>struct kset *kset_get(struct kset *kset);
void kset_put(struct kset *kset);
</PRE>
                        <P>一个 kset 还有一个名子, 存储于嵌入的 kobject. 因此, 如果你有一个 kset 称为 
                        my_set, 你将设置它的名子用:</P><PRE class=programlisting>kobject_set_name(&amp;my_set-&gt;kobj, "The name");
</PRE>
                        <P>ksets 还有一个指针( 在 ktye 成员 )指向 kobject_type 结构来描述它包含的 
                        kobject. 这个类型优先于在 kobject 自身中的 ktype 成员. 结果, 在典型的应用中, 在 
                        struct kobject 中的 ktype 成员被留为 NULL, 因为 kset 
                        中的相同成员是实际使用的那个.</P>
                        <P>最后, 一个 kset 包含一个子系统指针(称为 subsys). 
                        因此是时候讨论子系统了.</P></DIV>
                        <DIV class=sect3 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H4 class=title><A 
                        name=Subsystems.sect></A>14.1.2.3.&nbsp;子系统</H4></DIV></DIV></DIV>
                        <P>一个子系统是作为一个整体对内核一个高级部分的代表. 子系统常常(但是不是一直)出现在 sysfs 
                        层次的顶级. 一些内核中的例子子系统包括 block_subsys(/sys/block, 给块设备), 
                        devices_subsys(/sys/devices, 核心设备层次), 
                        以及一个特殊子系统给每个内核已知的总线类型. 一个驱动作者几乎从不需要创建一个新子系统; 如果你想这样做, 
                        再仔细想想. 你可能需要什么, 最后, 是增加一个新类别, 如同在"类别"一节中描述的.</P>
                        <P>一个子系统由一个简单结构代表:</P><PRE class=programlisting>struct subsystem {
 struct kset kset;
 struct rw_semaphore rwsem; 
}; 
</PRE>
                        <P>一个子系统, 因此, 其实只是一个对 kset 的包装, 有一个旗标丢在里面.</P>
                        <P>每个 kset 必须属于一个子系统. 子系统成员关系帮助建立 kset 的位置在层次中, 但是, 
                        更重要的, 子系统的 rwsem 旗标用来串行化对 kset 的内部链表的存取. 这个成员关系由在 struct 
                        kset 中的 subsys 指针所表示. 因此, 可以从 kset 的结构找到每个 kset 的包含子系统, 
                        但是却无法直接从子系统结构发现多个包含在子系统中的 kset. </P>
                        <P>子系统常常用一个特殊的宏声明:</P><PRE class=programlisting>decl_subsys(name, struct kobj_type *type, struct kset_hotplug_ops *hotplug_ops);
</PRE>
                        <P>这个宏创建一个 struct subsystem 使用一个给这个宏的名子并后缀以 _subsys 
                        而形成的名子. 这个宏还初始化内部的 kset 使用给定的 type 和 hotplug_ops. ( 
                        我们在本章后面讨论热插拔操作). </P>
                        <P>子系统有通常的建立和拆卸函数:</P><PRE class=programlisting>void subsystem_init(struct subsystem *subsys);
int subsystem_register(struct subsystem *subsys);
void subsystem_unregister(struct subsystem *subsys);
struct subsystem *subsys_get(struct subsystem *subsys)
void subsys_put(struct subsystem *subsys);
</PRE>
                        <P>大部分这些操作只是作用在子系统的 kset上.</P>
                        <DIV class=sect1 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H2 class=title style="CLEAR: both"><A 
                        name=LowLevelSysfsOperations.sect></A>14.2.&nbsp;低级 
                        sysfs 操作</H2></DIV></DIV></DIV>
                        <P>kobject 是在 sysfs 虚拟文件系统之后的机制. 对每个在 sysfs 中发现的目录, 有一个 
                        kobject 潜伏在内核某处. 每个感兴趣的 kobject 也输出一个或多个属性, 它出现在 kobject 
                        的 sysfs 目录, 作为包含内核产生的信息的文件. 本节检查 kobject 和 sysfs 
                        如何在低层交互.</P>
                        <P>使用 sysfs 的代码应当包含 &lt;linux/sysfs.h&gt;.</P>
                        <P>使一个 kobject 在 sysfs 出现仅仅是调用 kobject_add 的事情. 
                        我们已经见到这个函数作为添加一个 kobject 到一个 kset 的方式; 在 sysfs 
                        中创建入口也是它的工作的一部分. 有一些事情值得知道, 关于 sysfs 入口如何创建:</P>
                        <DIV class=itemizedlist>
                        <UL type=disc>
                          <LI>
                          <P>kobjects 的 sysfs 入口一直为目录, 因此一个对 kobject_add 
                          的调用导致在sysfs 中创建一个目录. 常常地, 这个目录包含一个或多个属性; 
                          我们稍后见到属性如何指定.</P>
                          <LI>
                          <P>分配给 kobject 的名字( 用 kobject_set_name ) 是给 sysfs 
                          目录使用的名字. 因此, 出现在 sysfs 层次的相同部分的 kobjects 必须有独特的名字. 分配给 
                          kobjects 的名字也应当是合理的文件名字: 它们不能包含斜线字符, 并且空白的使用强烈不推荐.</P>
                          <LI>
                          <P>sysfs 入口位于对应 kobject 的 parent 指针的目录中. 如果 parent 是 
                          NULL 当 kobject_add 被调用时, 它被设置为嵌在新 kobject 的 kset 中的 
                          kobject; 因此, sysfs 层级常常匹配使用 kset 创建的内部层次. 如果 parent 和 
                          kset 都是 NULL, sysfs 目录在顶级被创建, 
                        这几乎当然不是你所要的.</P></LI></UL></DIV>
                        <P>使用我们至今所描述的, 我们可以使用一个 kobject 来在 sysfs 中创建一个空目录. 常常地, 
                        你想做比这更有趣的事情, 因此是时间看属性的实现.</P>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=DefaultAttributes.sect></A>14.2.1.&nbsp;缺省属性</H3></DIV></DIV></DIV>
                        <P>当被创建时, 每个 kobject 被给定一套缺省属性. 这些属性通过 kobj_type 结构来指定. 
                        这个结构, 记住, 看来如此:</P><PRE class=programlisting>struct kobj_type {
 void (*release)(struct kobject *);
 struct sysfs_ops *sysfs_ops;
 struct attribute **default_attrs; 
}; 
</PRE>
                        <P>default_attr 成员列举了对每个这样类型的 kobject 被创建的属性, 并且 
                        sysfs_ops 提供方法来实现这些属性. 我们从 default_attrs 开始, 
                        它指向一个指向属性结构的指针数组:</P><PRE class=programlisting>struct attribute {
 char *name;
 struct module *owner;
 mode_t mode; 
}; 
</PRE>
                        <P>在这个结构中, name 是属性的名字( 如同它出现在 kobject 的 sysfs 目录中), 
                        owner 是一个指向模块的指针(如果有一个), 模块负责这个属性的实现, 并且 mode 
                        是应用到这个属性的保护位. mode 常常是 S_IRUGO 对于只读属性; 如果这个属性是可写的, 你可以扔出 
                        S_IWUSR 来只给 root 写权限( modes 的宏定义在 &lt;linux/stat.h&gt; 
                        中). default_attrs 列表中的最后一个入口必须用 0 填充.</P>
                        <P>default_attr 数组说明这些属性是什么, 但是没有告诉 sysfs 如何真正实现这些属性. 
                        这个任务落到 kobj_type-&gt;sysfs_ops 成员, 它指向一个结构, 定义为:</P><PRE class=programlisting>struct sysfs_ops {
 ssize_t (*show)(struct kobject *kobj, struct attribute *attr, char *buffer);
 ssize_t (*store)(struct kobject *kobj, struct attribute *attr, const char *buffer, size_t size);
};
</PRE>
                        <P>无论何时一个属性从用户空间读取, show 方法被用一个指向 kobject 
                        的指针和适当的属性结构来调用. 这个方法应当将给定属性值编码进缓冲, 要确定没有覆盖它( 它是 
                        PAGE_SIZE 字节), 并且返回实际的被返回数据的长度. sysfs 
                        的惯例表明每个属性应当包含一个单个的, 人可读的值; 如果你有许多消息返回, 
你可要考虑将它分为多个属性.</P>
                        <P>同样的 show 方法用在所有的和给定 kobject 关联的属性. 传递到函数的 attr 
                        指针可用来决定需要哪个属性. 一些 show 方法包含对属性名字的一系列测试. 
                        其他的实现将属性结构嵌入另一个结构, 来包含需要返回属性值的信息; 在这种情况下, container_of 
                        可能用在 show 方法中来获得一个指向嵌入结构的指针.</P>
                        <P>store 方法类似; 它应当将存在缓冲的数据编码( size 包含数据的长度, 这不能超过 
                        PAGE_SIZE ), 存储和以任何有意义的的方式响应新数据, 并且返回实际编码的字节数. store 
                        方法只在属性的许可允许写才被调用. 当编写一个 store 方法时, 不要忘记你在接收来自用户空间的任意信息; 
                        你应当在采取对应动作之前非常小心地验证它. 如果到数据不匹配期望, 返回一个负的错误值, 
                        而不是可能地做一些不想要的和无法恢复的事情. 如果你的设备输出一个自销毁的属性, 
                        你应当要求一个特定的字符串写到那里来引发这个功能; 一个偶然的, 随机写应当只产生一个错误.</P></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=NondefaultAttributes.sect></A>14.2.2.&nbsp;非缺省属性</H3></DIV></DIV></DIV>
                        <P>在许多情况中, kobject 类型的 default_attrs 成员描述所有的 kobject 
                        会拥有的属性. 但是那不是一个设计中的限制; 属性随意可以添加到和删除自 kojects. 
                        如果你想添加一个新属性到一个 kobject 的 sysfs 目录, 
简单地填充一个属性结构并且传递它到:</P><PRE class=programlisting>int sysfs_create_file(struct kobject *kobj, struct attribute *attr);
</PRE>
                        <P>如果所有都进行顺利, 文件被使用在属性结构中给定的名字创建, 并且返回值是 0; 否则, 
                        返回通常的负错误码.</P>
                        <P>注意, 相同的 show() 和 store() 函数被调用来实现对新属性的操作. 在你添加一个新的, 
                        非缺省属性到 kobject, 你应当任何必要的步骤来确保这些函数知道如何实现这个属性.</P>
                        <P>为去除一个属性, 调用:</P><PRE class=programlisting>int sysfs_remove_file(struct kobject *kobj, struct attribute *attr); 
</PRE>
                        <P>在调用后, 这个属性不再出现在 kobject 的 sysfs 入口. 要小心, 但是, 
                        一个用户空间进程可能有一个打开的那个属性的文件描述符, 并且在这个属性已经被去除后 show 和 store 
                        调用仍然可能.</P></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=BinaryAttributes.sect></A>14.2.3.&nbsp;二进制属性</H3></DIV></DIV></DIV>
                        <P>sysfs 惯例调用所有属性来包含一个单个的人可读文本格式的值. 就是说, 
                        只是偶然地很少需要来创建能够处理大量二进制数据的属性. 这个需要真正地只出现在必须传递数据, 不可动地, 
                        在用户空间和设备. 例如, 上载固件到设备需要这个特性. 当这样一个设备在系统中遇到, 一个用户程序可以被启动( 
                        通过热插拔机制); 这个程序接着传递固件代码到内核通过一个二进制 sysfs 属性, 
                        如同在"内核固件接口"一节中所示.</P>
                        <P>二进制属性使用一个 bin+attribute 结构来描述:</P><PRE class=programlisting>struct bin_attribute {
struct attribute attr;
size_t size;
ssize_t (*read)(struct kobject *kobj, char *buffer, loff_t pos, size_t size);
ssize_t (*write)(struct kobject *kobj, char *buffer, loff_t pos, size_t size);
};
</PRE>
                        <P>这里, attr 是一个属性结构, 给出名字, 拥有者, 和这个二进制属性的权限, 并且 size 
                        是这个二进制属性的最大大小(或者 0 , 如果没有最大值). read 和 write 
                        方法类似于正常的字符驱动对应物; 它们一次加载可被多次调用, 每次调用最大一页数据. 对于 sysfs 
                        没有办法来指示最后一个写操作, 因此实现二进制属性的代码必须能够以其他方式决定数据的结束.</P>
                        <P>二进制属性必须明确创建; 它们不能建立为缺省属性. 为创建一个二进制属性, 调用:</P><PRE class=programlisting>int sysfs_create_bin_file(struct kobject *kobj, struct bin_attribute *attr);
</PRE>
                        <P>去除二进制属性可用:</P><PRE class=programlisting>int sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);
</PRE></DIV>
                        <DIV class=sect2 lang=zh-cn>
                        <DIV class=titlepage>
                        <DIV>
                        <DIV>
                        <H3 class=title><A 
                        name=SymbolicLinks.sect></A>14.2.4.&nbsp;符号连接</H3></DIV></DIV></DIV>
                        <P>sysfs 文件系统有通常的树结构, 反映它代表的 kobjects 的层次组织. 
                        但是内核中对象间的关系常常比那个更加复杂. 例如, 一个 sysfs 子树 (/sys/devices 
                        )代表所有的系统已知的设备, 而其他的子树( 在 /sys/bus 之下 )表示设备驱动. 这些树, 但是, 
                        不代表驱动和它们所管理的设备间的关系. 展示这些附加关系需要额外的指针, 指针在 sysfs 
                        中通过符号连接实现.</P>
                        <P>创建一个符号连接在 sysfs 是容易的:</P><PRE class=programlisting>int sysfs_create_link(struct kobject *kobj, struct kobject *target, char *name);
</PRE>
                        <P>这个函数创建一个连接(称为 name)指向目标的 sysfs 入口作为一个 kobj 的属性. 
                        它是一个相对连接, 因此它不管 sysfs 在任何特殊的系统中安装在哪里都可用.</P>
                        <P>这个连接甚至当目标被从系统中移走也持续. 如果你在创建对其他 kobjects 的符号连接, 
                        你应当可能有一个方法知道对这个 kobjects 的改变, 或者某种保证目标 kobjects 不会消失. 
                        结果( 在 sysfs 中的死的符号连接 )不是特别严重, 
                        但是它们不代表最好的编程风格并且可能导致在用户空间的混乱.</P>
                        <P>去除符号连接可使用:</P><PRE class=programlisting>void sysfs_remove_link(struct kobject *kobj, char *name); 
</PRE><PRE class=programlisting><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=HotplugEventGeneration.sect></A>14.3.&nbsp;热插拔事件产生</H2></DIV></DIV></DIV><P>一个热插拔事件是一个从内核到用户空间的通知, 在系统配置中有事情已经改变. 无论何时一个 kobject 被创建或销毁就产生它们. 这样事件被产生, 例如, 当一个数字摄像头使用一个 USB 线缆插入, 当一个用户切换控制台模式, 或者当一个磁盘被重新分区. 热插拔事件转变为一个对 /sbin/hotplug 的调用, 它响应每个事件, 通过加载驱动, 创建设备节点, 安装分区, 或者采取任何其他的合适的动作.</P><P>我们所见的最后一个主要的 kobject 函数是这些事件的产生. 实际的事件在当一个 kobject 传递到 kobject_add 或 kobject_del 时发生. 在这个事件被传递到用户空间之前, 和这个 kobject 关联的代码( 或者, 更特别的, 它所属的 kset )有机会来添加信息给用户空间或者来完全关闭事件的产生.</P><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=HotplugOperations.sect></A>14.3.1.&nbsp;热插拔操作</H3></DIV></DIV></DIV><P>热插拔事件的实际控制是通过一套存储于 kset_hotplug_ops 结构的方法完成.</P><PRE class=programlisting>struct kset_hotplug_ops {
 int (*filter)(struct kset *kset, struct kobject *kobj);
 char *(*name)(struct kset *kset, struct kobject *kobj);
 int (*hotplug)(struct kset *kset, struct kobject *kobj,
 char **envp, int num_envp, char *buffer,
 int buffer_size);
};
</PRE><P>一个指向这个结构的指针在 kset 结构的 hotplug_ops 成员中. 如果一个给定的 kobject 不包含在一个 kset 中, 内核搜索整个层次( 通过 parent 指针) 直到它发现一个 kobject 确实有一个 kset; 接着使用这个 kset 的热插拔操作.</P><P>filter 热插拔操作被调用无论何时内核在考虑为给定 kobject 产生一个事件. 如果 filter 返回 0, 事件没有创建. 这个方法, 因此, 给 kset 代码一个机会来决定哪个事件应当被传递给用户空间以及哪个不.</P><P>作为一个例子关于这个方法怎样被使用, 考虑块设备子系统. 至少有 3 类 kobject 用在那里, 表示磁盘, 分区, 和请求队列. 用户空间可能想对磁盘或分区的增加作出反应, 但是它正常地不关心请求队列. 因此 filter 方法允许事件产生只给代表磁盘和分区的 kobjects. 它看来如此:</P><PRE class=programlisting>static int block_hotplug_filter(struct kset *kset, struct kobject *kobj)
{

 struct kobj_type *ktype = get_ktype(kobj);
    return ((ktype == &amp;ktype_block) || (ktype == &amp;ktype_part));
}
</PRE><P>这里, 一个快速的在 kobject 类型上的测试是足以决定是否这个事件应当产生或者不.</P><P>当用户空间热插拔程序被调用, 它被传递给相关子系统的 name 作为它唯一的一个参数. name 热插拔方法负责提供这个名子. 它应当返回一个简单的适合传递给用户空间的字串.</P><P>热插拔脚本的可能想知道的其他所有东东都在环境中传递. 最终的热插拔方法( hotplug )给了一个机会来在调用这个脚本之前添加有用的环境变量. 再次, 这个方法的原型是:</P><PRE class=programlisting>int (*hotplug)(struct kset *kset, struct kobject *kobj,
 char **envp, int num_envp, char *buffer,
 int buffer_size); 
</PRE><P>如常, kset 和 kobject 描述事件产生给的对象. envp 数组是一个地方来存储额外的环境变量定义(以通常的 NAME=值 的格式); 它有 num_envp 个入口变量. 这些变量自身应当被编码入缓冲, 缓冲是 buffer_size 字节长. 如果你添加任何变量到 envp, 确信添加一个 NULL 入口在你最后的添加项后面, 这样内核知道结尾在哪里. 返回值正常应当是 0; 任何非零返回都终止热插拔事件的产生.</P><P>热插拔事件的产生(象在设备模型中大部分工作)常常是由在总线驱动级的逻辑处理.</P><P>&nbsp;</P><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=BuesDevicesandDrivers.sect></A>14.4.&nbsp;总线, 设备, 和驱动</H2></DIV></DIV></DIV><P>至今, 我们已经看到大量低级框架和一个相对少的例子. 我们试图在本章剩下部分中补充, 随着我们进入 Linux 设备模型的更高级. 为此, 我们介绍一个新的虚拟总线, 我们称为 lddbus, <SUP>[<A href="http://www.deansys.com/doc/ldd3/ch14s04.html#ftn.id485223" name=id485223><FONT color=#0000ff>46</FONT></A>]</SUP>并且修改 scullp 驱动来 "接入" 到这个总线.</P><P>再一次, 许多驱动作者将不会需要这里涉及的材料. 这个水平的细节通常在总线级别处理, 并且很少作者需要添加一个新总线类型. 这个信息是有用的, 但是, 对任何人好奇在 PCI, USB 等层面的里面发生了什么或者谁需要在那个级别做改变. </P><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=Buses.sect></A>14.4.1.&nbsp;总线</H3></DIV></DIV></DIV><P>一个总线是处理器和一个或多个设备之间的通道. 为设备模型的目的, 所有的设备都通过一个总线连接, 甚至当它是一个内部的虚拟的,"平台"总线. 总线可以插入另一个 - 一个 USB 控制器常常是一个 PCI 设备, 例如. 设备模型表示在总线和它们控制的设备之间的实际连接.</P><P></P><P>在 Linux 设备模型中, 一个总线由 bus_type 结构代表, 定义在 &lt;linux/device.h&gt;. 这个结构看来象:</P><PRE class=programlisting>struct bus_type {
 char *name;
 struct subsystem subsys;
 struct kset drivers;
 struct kset devices;
 int (*match)(struct device *dev, struct device_driver *drv);
 struct device *(*add)(struct device * parent, char * bus_id);
 int (*hotplug) (struct device *dev, char **envp,
 int num_envp, char *buffer, int buffer_size);
 /* Some fields omitted */
};
</PRE><P>name 成员是总线的名子, 有些同 pci. 你可从这个结构中见到每个总线是它自己的子系统; 这个子系统不位于 sysfs 的顶层, 但是. 相反, 它们在总线子系统下面. 一个总线包含 2 个 ksets, 代表已知的总线的驱动和所有插入总线的设备. 所以, 有一套方法我们马上将涉及.</P><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Busregisteration.sect></A>14.4.1.1.&nbsp;总线注册</H4></DIV></DIV></DIV><P>如同我们提过的, 例子源码包含一个虚拟总线实现称为 lddbus. 这个总线建立它的 bus_type 结构, 如下:</P><PRE class=programlisting>struct bus_type ldd_bus_type = { .name = "ldd", .match = ldd_match, .hotplug = ldd_hotplug, };
</PRE><P>注意很少 bus_type 成员要求初始化; 大部分由设备模型核心处理. 但是, 我们确实不得不指定总线的名子, 以及任何伴随它的方法.</P><P>不可避免地, 一个新总线必须注册到系统, 通过一个对 bus_register 的调用. lddbus 代码这样做以这样的方式:</P><PRE class=programlisting>ret = bus_register(&amp;ldd_bus_type);
if (ret)
 return ret; 
</PRE><P>这个调用可能失败, 当然, 因此返回值必须一直检查. 如果它成功, 新总线子系统已被添加到系统; 在 sysfs 中 /sys/bus 的下面可以见到, 并且可能启动添加设备.</P><P>如果有必要从系统中去除一个总线(当关联模块被去除, 例如), 调用调用 bus_unregister:</P><PRE class=programlisting>void bus_unregister(struct bus_type *bus); 
</PRE></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Busmethods.sect></A>14.4.1.2.&nbsp;总线方法</H4></DIV></DIV></DIV><P>有几个给 bus_type 结构定义的方法; 它们允许总线代码作为一个设备核心和单独驱动之间的中介. 在 2.6.10 内核中定义的方法是:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>int (*match)(struct device *device, struct device_driver *driver);</SPAN></SPAN> <DD><P>这个方法被调用, 大概多次, 无论何时一个新设备或者驱动被添加给这个总线. 它应当返回一个非零值如果给定的设备可被给定的驱动处理. (我们马上进入设备和 device_driver 结构的细节). 这个函数必须在总线级别处理, 因为那是合适的逻辑存在的地方; 核心内核不能知道如何匹配每个可能总线类型的设备和驱动.</P><DT><SPAN class=term><SPAN>int (*hotplug) (struct device *device, char **envp, int num_envp, char *buffer, int buffer_size);</SPAN></SPAN> <DD><P>这个模块允许总线添加变量到环境中, 在产生一个热插拔事件在用户空间之前. 参数和 kset 热插拔方法相同( 在前面的 "热插拔事件产生" 一节中描述 ).</P></DD></DL></DIV><P>lddbus 驱动有一个非常简单的匹配函数, 它仅仅比较驱动和设备的名子:</P><PRE class=programlisting>static int ldd_match(struct device *dev, struct device_driver *driver)
{
 return !strncmp(dev-&gt;bus_id, driver-&gt;name, strlen(driver-&gt;name));
}
</PRE><P>当涉及到真实硬件, match 函数常常在有设备自身提供的硬件 ID 和驱动提供的 ID 之间, 做一些比较.</P><P>lddbus 热插拔方法看来象这样:</P><PRE class=programlisting>static int ldd_hotplug(struct device *dev, char **envp, int num_envp, char *buffer, int buffer_size)
{
 envp[0] = buffer;
 if (snprintf(buffer, buffer_size, "LDDBUS_VERSION=%s",
 Version) &gt;= buffer_size)
 return -ENOMEM;
 envp[1] = NULL;
 return 0;
}
</PRE><P>这里, 我们加入 lddbus 源码的当前版本号, 只是以防有人好奇.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Iteratingoverdevicesanddrivers.sect></A>14.4.1.3.&nbsp;列举设备和驱动</H4></DIV></DIV></DIV><P>如果你在编写总线级别的代码, 你可能不得不对所有已经注册到你的总线的设备或驱动进行一些操作. 它可能会诱惑人直接进入 bus_type 结构中的各种结构, 但是最好使用已经提供的帮助函数.</P><P>为操作每个对总线已知的设备, 使用:</P><PRE class=programlisting>int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data, int (*fn)(struct device *, void *));
</PRE><P>这个函数列举总线上的每个设备, 传递关联的设备结构给 fn, 连同作为 data 来传递的值. 如果 start 是 NULL, 列举从总线的第一个设备开始; 否则列举从 start 之后的第一个设备开始. 如果 fn 返回一个非零值, 列举停止并且那个值从 bus_for_each_dev 返回.</P><P>有一个类似的函数来列举驱动:</P><PRE class=programlisting>int bus_for_each_drv(struct bus_type *bus, struct device_driver *start, void *data, int (*fn)(struct device_driver *, void *));
</PRE><P>这个函数就像 buf_for_each_dev, 除了, 当然, 它替之作用于驱动.</P><P>应当注意, 这 2 个函数持有总线子系统的读者/写者旗标在工作期间. 因此试图一起使用这 2 个会死锁 -- 每个将试图获取同一个旗标. 修改总线的操作( 例如注销设备 )也将锁住. 因此, 小心使用 bus_for_each 函数.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Busattributes.sect></A>14.4.1.4.&nbsp;总线属性</H4></DIV></DIV></DIV><P>几乎 Linux 驱动模型中的每一层都提供一个添加属性的接口, 并且总线层不例外. bus_attribute 类型定义在 &lt;linux/device.h&gt; 如下:</P><PRE class=programlisting>struct bus_attribute {
 struct attribute attr;
 ssize_t (*show)(struct bus_type *bus, char *buf);
 ssize_t (*store)(struct bus_type *bus, const char *buf,
 size_t count);
};
</PRE><P>我们已经见到 struct attribute 在 "缺省属性" 一节. bus_attribute 类型也包含 2 个方法来显示和设置属性值. 大部分在 kobject 之上的设备模型层以这种方式工作.</P><P>已经提供了一个方便的宏为在编译时间创建和初始化 bus_attribute 结构:</P><PRE class=programlisting>BUS_ATTR(name, mode, show, store);
</PRE><P>这个宏声明一个结构, 产生它的名子通过前缀字符串 bus_attr_ 到给定的名子.</P><P>任何属于一个总线的属性应当明确使用 bus_create_file 来创建:</P><PRE class=programlisting>int bus_create_file(struct bus_type *bus, struct bus_attribute *attr); 
</PRE><P>属性也可被去除, 使用:</P><PRE class=programlisting>void bus_remove_file(struct bus_type *bus, struct bus_attribute *attr); 
</PRE><P>lddbus 驱动创建一个简单属性文件, 再次, 包含源码版本号. show 方法和 bus_attribute 结构设置如下:</P><PRE class=programlisting>static ssize_t show_bus_version(struct bus_type *bus, char *buf)
{
 return snprintf(buf, PAGE_SIZE, "%s\n", Version);
}

static BUS_ATTR(version, S_IRUGO, show_bus_version, NULL); 
</PRE><P>创建属性文件在模块加载时间完成:</P><PRE class=programlisting>if (bus_create_file(&amp;ldd_bus_type, &amp;bus_attr_version))
 printk(KERN_NOTICE "Unable to create version attribute\n");
</PRE><P>这个调用创建一个属性文件(/sys/busldd/version) 包含 lddbus 代码的版本号.</P></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=Devices.sect></A>14.4.2.&nbsp;设备</H3></DIV></DIV></DIV><P>在最低层, Linux 系统中的每个设备由一个 struct device 代表:</P>struct device { struct device *parent; struct kobject kobj; char bus_id[BUS_ID_SIZE]; struct bus_type *bus; struct device_driver *driver; void *driver_data; void (*release)(struct device *dev); /* Several fields omitted */ }; <P>有许多其他的 struct device 成员只对设备核心代码感兴趣. 但是, 这些成员值得了解:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>struct device *parent </SPAN></SPAN><DD><P>设备的 "parent" 设备 -- 它所附着到的设备. 在大部分情况, 一个父设备是某种总线或者主控制器. 如果 parent 是 NULL, 设备是一个顶层设备, 这常常不是你所要的.</P><DT><SPAN class=term><SPAN>struct kobject kobj;</SPAN></SPAN> <DD><P>代表这个设备并且连接它到层次中的 kobject. 注意, 作为一个通用的规则, device-&gt;kobj-&gt;parent 等同于 device-&gt;parent-&gt;kobj.</P><DT><SPAN class=term><SPAN>char bus_id[BUS_ID_SIZE];</SPAN></SPAN> <DD><P>唯一确定这个总线上的设备的字符串. PCI 设备, 例如, 使用标准的 PCI ID 格式, 包含域, 总线, 设备, 和功能号.</P><DT><SPAN class=term><SPAN>struct bus_type *bus;</SPAN></SPAN> <DD><P>确定设备位于哪种总线.</P><DT><SPAN class=term><SPAN>struct device_driver *driver;</SPAN></SPAN> <DD><P>管理这个设备的驱动; 我们查看 struct device_driver 在下一节.</P><DT><SPAN class=term><SPAN>void *driver_data;</SPAN></SPAN> <DD><P>一个可能被设备驱动使用的私有数据成员.</P><DT><SPAN class=term><SPAN>void (*release)(struct device *dev);</SPAN></SPAN> <DD><P>当对这个设备的最后引用被去除时调用的方法; 它从被嵌入的 kobject 的 release 方法被调用. 注册到核心的所有的设备结构必须有一个 release 方法, 否则内核打印出慌乱的抱怨.</P></DD></DL></DIV><P>最少, parent, bus_id, bus, 和 release 成员必须在设备结构被注册前设置.</P><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Deviceregisteration.sect></A>14.4.2.1.&nbsp;设备注册</H4></DIV></DIV></DIV><P>通常的注册和注销函数在:</P><PRE class=programlisting>int device_register(struct device *dev);
void device_unregister(struct device *dev);
</PRE><P>我们已经见到 lddbus 代码如何注册它的总线类型. 但是, 一个实际的总线是一个设备并且必须单独注册. 为简单起见, lddbus 模块只支持一个单个虚拟总线, 因此这个驱动在编译时建立它的设备:</P><PRE class=programlisting>static void ldd_bus_release(struct device *dev)
{
 printk(KERN_DEBUG "lddbus release\n");
}

struct device ldd_bus = {
 .bus_id = "ldd0",
 .release = ldd_bus_release

}; 
</PRE><P>这是顶级总线, 因此 parent 和 bus 成员留为 NULL. 我们有一个简单的, no-op release 方法, 并且, 作为第一个(并且唯一)总线, 它的名子时 ldd0. 这个总线设备被注册, 使用:</P><PRE class=programlisting>ret = device_register(&amp;ldd_bus);
if (ret)
 printk(KERN_NOTICE "Unable to register ldd0\n");
</PRE><P>一旦调用完成, 新总线可在 sysfs 中 /sys/devices 下面见到. 任何加到这个总线的设备接着在 /sys/devices/ldd0 下显示.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Deviceattributes.sect3></A>14.4.2.2.&nbsp;设备属性</H4></DIV></DIV></DIV><P>sysfs 中的设备入口可有属性. 相关的结构是:</P><PRE class=programlisting>struct device_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device *dev, char *buf);
 ssize_t (*store)(struct device *dev, const char *buf,
 size_t count);
};
</PRE><P>这些属性结构可在编译时建立, 使用这些宏:</P><PRE class=programlisting>DEVICE_ATTR(name, mode, show, store);
</PRE><P>结果结构通过前缀 dev_attr_ 到给定名子上来命名. 属性文件的实际管理使用通常的函数对来处理:</P><PRE class=programlisting>int device_create_file(struct device *device, struct device_attribute *entry);
void device_remove_file(struct device *dev, struct device_attribute *attr);
</PRE><P>struct bus_type 的 dev_attrs 成员指向一个缺省的属性列表, 这些属性给添加到总线的每个设备创建.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Devicestructureembedding.sect3></A>14.4.2.3.&nbsp;设备结构嵌入</H4></DIV></DIV></DIV><P>设备结构包含设备模型核心需要的来模型化系统的信息. 大部分子系统, 但是, 跟踪关于它们驻留的设备的额外信息. 结果, 对设备很少由空设备结构所代表; 相反, 这个结构, 如同 kobject 结构, 常常是嵌入一个更高级的设备表示中. 如果你查看 struct pci_dev 的定义或者 struct usb_device 的定义, 你会发现一个 struct device 埋在其中. 常常地, 低层驱动甚至不知道 struct device, 但是有例外.</P><P>lddbus 驱动创建它自己的设备类型( struct ldd_device ) 并且期望单独的设备驱动来注册它们的设备使用这个类型. 它是一个简单结构:</P><PRE class=programlisting>struct ldd_device {
 char *name;
 struct ldd_driver *driver;
 struct device dev; 
}; 
#define to_ldd_device(dev) container_of(dev, struct ldd_device, dev); 
</PRE><P>这个结构允许驱动提供一个实际的名子给设备( 这可以清楚地不同于它的总线 ID, 存储于设备结构) 以及一个这些驱动信息的指针. 给真实设备的结构常常还包含关于供应者信息, 设备型号, 设备配置, 使用的资源, 等等. 可以在 struct pci_dev (&lt;linux/pci.h&gt;) 或者 struct usb_device (&lt;linux/usb.h&gt;) 中找到好的例子. 一个方便的宏( to_ldd_device ) 也为 struct ldd_device 定义, 使得容易转换指向被嵌入的结构的指针为 ldd_device 指针.</P><P>lddbus 输出的注册接口看来如此:</P><PRE class=programlisting>int register_ldd_device(struct ldd_device *ldddev) 
{
 ldddev-&gt;dev.bus = &amp;ldd_bus_type;
 ldddev-&gt;dev.parent = &amp;ldd_bus;
 ldddev-&gt;dev.release = ldd_dev_release;
 strncpy(ldddev-&gt;dev.bus_id, ldddev-&gt;name, BUS_ID_SIZE);
 return device_register(&amp;ldddev-&gt;dev);

}
EXPORT_SYMBOL(register_ldd_device);
</PRE><P>这里, 我们简单地填充一些嵌入的设备结构成员( 单个驱动不应当需要知道这个 ), 并且注册这个设备到驱动核心. 如果我们想添加总线特定的属性到设备, 我们可在这里做.</P><P>为显示这个接口如何使用, 我们介绍另一个例子驱动, 我们称为 sculld. 它是在第 8 章介绍的 scullp 驱动上的另一个变体. 它实现通用的内存区设备, 但是 sculld 也使用 Linux 设备模型, 通过 lddbus 接口.</P><P>sculld 驱动添加一个它自己的属性到它的设备入口; 这个属性, 称为 dev, 仅仅包含关联的设备号. 这个属性可被一个模块用来加载脚本或者热插拔子系统, 来自动创建设备节点, 当设备被添加到系统时. 这个属性的设置遵循常用模式:</P><PRE class=programlisting>static ssize_t sculld_show_dev(struct device *ddev, char *buf)
{
 struct sculld_dev *dev = ddev-&gt;driver_data;

 return print_dev_t(buf, dev-&gt;cdev.dev);
}

static DEVICE_ATTR(dev, S_IRUGO, sculld_show_dev, NULL);
</PRE><P>接着, 在初始化时间, 设备被注册, 并且 dev 属性被创建通过下面的函数:</P><PRE class=programlisting>static void sculld_register_dev(struct sculld_dev *dev, int index) 
{
 sprintf(dev-&gt;devname, "sculld%d", index);
 dev-&gt;ldev.name = dev-&gt;devname;
 dev-&gt;ldev.driver = &amp;sculld_driver;
 dev-&gt;ldev.dev.driver_data = dev;
 register_ldd_device(&amp;dev-&gt;ldev);
 device_create_file(&amp;dev-&gt;ldev.dev, &amp;dev_attr_dev);

} 
</PRE><P>注意, 我们使用 driver_data 成员来存储指向我们自己的内部的设备结构的指针.</P></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=DeviceDrivers.sect2></A>14.4.3.&nbsp;设备驱动</H3></DIV></DIV></DIV><P>设备模型跟踪所有对系统已知的驱动. 这个跟踪的主要原因是使驱动核心能匹配驱动和新设备. 一旦驱动在系统中是已知的对象, 但是, 许多其他的事情变得有可能. 设备驱动可输出和任何特定设备无关的信息和配置变量, 例如:</P><P>驱动由下列结构定义:</P><PRE class=programlisting>struct device_driver {
 char *name;
 struct bus_type *bus;
 struct kobject kobj;
 struct list_head devices;
 int (*probe)(struct device *dev);
 int (*remove)(struct device *dev);
 void (*shutdown) (struct device *dev);
}; 
</PRE><P>再一次, 几个结构成员被忽略( 全部内容见 &lt;linux/device.h&gt; ). 这里, name 是驱动的名子( 它在 sysfs 中出现 ), bus 是这个驱动使用的总线类型, kobj 是必然的 kobject, devices 是当前绑定到这个驱动的所有设备的列表, probe 是一个函数被调用来查询一个特定设备的存在(以及这个驱动是否可以使用它), remove 当设备从系统中去除时被调用, shutdown 在关闭时被调用来关闭设备.</P><P>使用 device_driver 结构的函数的形式, 现在应当看来是类似的(因此我们快速涵盖它们). 注册函数是:</P><PRE class=programlisting>int driver_register(struct device_driver *drv);
void driver_unregister(struct device_driver *drv);
</PRE><P>通常的属性结构在:</P><PRE class=programlisting>struct driver_attribute {
 struct attribute attr;
 ssize_t (*show)(struct device_driver *drv, char *buf);
 ssize_t (*store)(struct device_driver *drv, const char *buf,

 size_t count);
};
DRIVER_ATTR(name, mode, show, store);
</PRE><P>以及属性文件以通常的方法创建:</P><PRE class=programlisting>int driver_create_file(struct device_driver *drv, struct driver_attribute *attr);
void driver_remove_file(struct device_driver *drv, struct driver_attribute *attr);
</PRE><P>bus_type 结构含有一个成员( drv_attrs ) 指向一套缺省属性, 对所有关联到这个总线的驱动都创建.</P><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Driverstructureembedding.sect></A>14.4.3.1.&nbsp;驱动结构嵌入</H4></DIV></DIV></DIV><P>如同大部分驱动核心结构的情形, device_driver 结构常常被发现嵌到一个更高级的, 总线特定的结构. lddbus 子系统不会和这样的趋势相反, 因此它已定义了它自己的 ldd_driver 结构:</P><PRE class=programlisting>struct ldd_driver {
 char *version;
 struct module *module;
 struct device_driver driver;
 struct driver_attribute version_attr; 
}; 
#define to_ldd_driver(drv) container_of(drv, struct ldd_driver, driver); 
</PRE><P>这里, 我们要求每个驱动提供特定当前软件版本, 并且 lddbus 输出这个版本字串为它知道的每个驱动. 总线特定的驱动注册函数是:</P><PRE class=programlisting>int register_ldd_driver(struct ldd_driver *driver)
{

 int ret;
 driver-&gt;driver.bus = &amp;ldd_bus_type;
 ret = driver_register(&amp;driver-&gt;driver);
 if (ret)
 return ret;
 driver-&gt;version_attr.attr.name = "version";
 driver-&gt;version_attr.attr.owner = driver-&gt;module;
 driver-&gt;version_attr.attr.mode = S_IRUGO;
 driver-&gt;version_attr.show = show_version;
 driver-&gt;version_attr.store = NULL;
 return driver_create_file(&amp;driver-&gt;driver, &amp;driver-&gt;version_attr);
}
</PRE><P>这个函数的第一部分只注册低级的 device_driver 结构到核心; 剩下的建立版本属性. 因为这个属性在运行时被创建, 我们不能使用 DRIVER_ATTR 宏; 反之, driver_attribute 结构必须手工填充. 注意我们设定属性的拥有者为驱动模块, 不是 lddbus 模块; 这样做的理由是可以在为这个属性的 show 函数的实现中见到:</P><PRE class=programlisting>static ssize_t show_version(struct device_driver *driver, char *buf)
{

 struct ldd_driver *ldriver = to_ldd_driver(driver);
 sprintf(buf, "%s\n", ldriver-&gt;version);
 return strlen(buf);
}
</PRE><P>有人可能认为属性拥有者应当是 lddbus 模块, 因为实现这个属性的函数在那里定义. 这个函数, 但是, 是使用驱动自身所创建的 ldd_driver 结构. 如果那个结构在一个用户空间进程试图读取版本号时要消失, 事情会变得麻烦. 指定驱动模块作为属性的拥有者阻止了模块被卸载, 在用户空间保持属性文件打开时. 因为每个驱动模块创建一个对 lddbus 模块的引用, 我们能确信 lddbus 不会在一个不合适的时间被卸载.</P><P>为完整起见, sculld 创建它的 ldd_driver 结构如下:</P><PRE class=programlisting>static struct ldd_driver sculld_driver = { .version = "$Revision: 1.1 $", .module = THIS_MODULE, .driver = { .name = "sculld", }, }; 
</PRE><P>一个简单的对 register_ldd_driver 的调用添加它到系统中. 一旦完成初始化, 驱动信息可在 sysfs 中见到:</P><PRE class=screen>$ tree /sys/bus/ldd/drivers 
/sys/bus/ldd/drivers 
`-- sculld
 |-- sculld0 -&gt; ../../../../devices/ldd0/sculld0
 |-- sculld1 -&gt; ../../../../devices/ldd0/sculld1
 |-- sculld2 -&gt; ../../../../devices/ldd0/sculld2
 |-- sculld3 -&gt; ../../../../devices/ldd0/sculld3
 `-- version 
</PRE></DIV></DIV><DIV class=footnotes><BR><HR align=left width=100><DIV class=footnote><P><SUP>[<A href="http://www.deansys.com/doc/ldd3/ch14s04.html#id485223" name=ftn.id485223><FONT color=#0000ff>46</FONT></A>] </SUP>这个总线的逻辑名子, 当然, 应当是"sbus", 但是这个名子已经被一个真实的, 物理总线采用.</P><P>&nbsp;</P><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=Classes.sect1></A>14.5.&nbsp;类</H2></DIV></DIV></DIV><P>我们在本章中要考察最后的设备模型概念是类.一个类是一个设备的高级视图, 它抽象出低级的实现细节. 驱动可以见到一个SCSI 磁盘或者一个 ATA 磁盘, 在类的级别, 它们都是磁盘. 类允许用户空间基于它们做什么来使用设备, 而不是它们如何被连接或者它们如何工作.</P><P>几乎所有的类都在 sysfs 中在 /sys/class 下出现. 因此, 例如, 所有的网络接口可在 /sys/class/net 下发现, 不管接口类型. 输入设备可在 /sys/class/input 下, 以及串行设备在 /sys/class/tty. 一个例外是块设备, 由于历史的原因在 /sys/block. </P><P>类成员关系常常由高级的代码处理, 不必要驱动的明确的支持. 当 sbull 驱动( 见 16 章) 创建一个虚拟磁盘设备, 它自动出现在 /sys/block. snull 网络驱动(见 17 章)没有做任何特殊事情给它的接口在 /sys/class/net 中出现. 将有多次, 但是, 当驱动结束直接处理类.</P><P>在许多情况, 类子系统是最好的输出信息到用户空间的方法. 当一个子系统创建一个类, 它完全拥有这个类, 因此没有必要担心哪个模块拥有那里发现的属性. 它也用极少的时间徘徊于更加面向硬件的 sysfs 部分来了解, 它不是一个直接浏览的好地方. 用户会更加高兴地在 /sys/class/some-widget 中发现信息, 而不是, /sys/device/pci0000:00/0000:00:10.0/usb2/2-0:1.0.</P><P>驱动核心输出 2 个清晰的接口来管理类. class_simple 函数设计来尽可能容易地添加新类到系统. 它们的主要目的, 常常, 是暴露包含设备号的属性来使能设备节点的自动创建. 常用的类接口更加复杂但是同时提供更多特性. 我们从简单版本开始.</P><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=TheclasssimpleInterface.sect2></A>14.5.1.&nbsp;class_simple 接口</H3></DIV></DIV></DIV><P>class_simple 接口意图是易于使用, 以至于没人会抱怨没有暴露至少一个包含设备的被分配的号的属性. 使用这个接口只不过是一对函数调用, 没有通常的和 Linux 设备模型关联的样板.</P><P>第一步是创建类自身. 使用一个对 class_simple_create 的调用来完成:</P><PRE class=programlisting>struct class_simple *class_simple_create(struct module *owner, char *name);
</PRE><P>这个函数使用给定的名子创建一个类. 这个操作可能失败, 当然, 因此在继续之前返回值应当一直被检查( 使用 IS_ERR, 在第 1 章的"指针和错误值"一节中描述过).</P><P>一个简单的类可被销毁, 使用:</P><PRE class=programlisting>void class_simple_destroy(struct class_simple *cs); 
</PRE><P>创建一个简单类的真实目的是添加设备给它; 这个任务使用:</P><PRE class=programlisting>struct class_device *class_simple_device_add(struct class_simple *cs, dev_t devnum, struct device *device, const char *fmt, ...); 
</PRE><P>这里, cs 是之前创建的简单类, devnum 是分配的设备号, device 是代表这个设备的 struct device, 其他的参数是一个 printk-风格 的格式串和参数来创建设备名子. 这个调用添加一项到类, 包含一个属性, dev, 含有设备号. 如果设备参数是非 NULL, 一个符号连接( 称为 device )指向在 /sys/devices 下的设备的入口.</P><P>可能添加其他的属性到设备入口. 它只是使用 class_device_create_file, 我们在下一节和完整类子系统所剩下的内容讨论.</P><P>当设备进出时类产生热插拔事件. 如果你的驱动需要添加变量到环境中给用户空间事件处理者, 可以建立一个热插拔回调, 使用:</P><PRE class=programlisting>int class_simple_set_hotplug(struct class_simple *cs,
 int (*hotplug)(struct class_device *dev,
 char **envp, int num_envp,
 char *buffer, int buffer_size)); 
</PRE><P>当你的设备离开时, 类入口应当被去除, 使用:</P><PRE class=programlisting>void class_simple_device_remove(dev_t dev); 
</PRE><P>注意, 由 class_simple_device_add 返回的 class_device 结构这里不需要; 设备号(它当然应当是唯一的)足够了.</P></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=TheFullClassInterface.sect2></A>14.5.2.&nbsp;完整的类接口</H3></DIV></DIV></DIV><P>class_simple 接口满足许多需要, 但是有时需要更多灵活性. 下面的讨论描述如何使用完整的类机制, class_simple 正是基于此. 它是简短的: 类函数和结构遵循设备模型其他部分相同的模式, 因此这里没有什么真正是新的.</P><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Managingclasses.sect3></A>14.5.2.1.&nbsp;管理类</H4></DIV></DIV></DIV><P>一个类由一个 struct class 的实例来定义:</P><PRE class=programlisting>struct class {
 char *name;
 struct class_attribute *class_attrs;
 struct class_device_attribute *class_dev_attrs;
 int (*hotplug)(struct class_device *dev, char **envp,
 int num_envp, char *buffer, int buffer_size);
 void (*release)(struct class_device *dev);
 void (*class_release)(struct class *class);
 /* Some fields omitted */
};
</PRE><P>每个类需要一个唯一的名子, 它是这个类如何在 /sys/class 中出现. 当这个类被注册, 由 class_attrs 所指向的数组中列出的所有属性被创建. 还有一套缺省属性给每个添加到类中的设备; class_dev_attrs 指向它们. 有通常的热插拔函数来添加变量到环境中, 当事件产生时. 还有 2 个释放方法: release 在无论何时从类中去除一个设备时被调用, 而 class_release 在类自己被释放时调用.</P><P>注册函数是:</P><PRE class=programlisting>int class_register(struct class *cls);
void class_unregister(struct class *cls);
</PRE><P>使用属性的接口不应当在这点吓人:</P><PRE class=programlisting>struct class_attribute {
 struct attribute attr;
 ssize_t (*show)(struct class *cls, char *buf);
 ssize_t (*store)(struct class *cls, const char *buf, size_t count); 
}; 
CLASS_ATTR(name, mode, show, store); 
int class_create_file(struct class *cls, const struct class_attribute *attr);
void class_remove_file(struct class *cls, const struct class_attribute *attr);
</PRE></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Classdevices.sect3></A>14.5.2.2.&nbsp;类设备</H4></DIV></DIV></DIV><P>一个类的真正目的是作为一个是该类成员的设备的容器. 一个成员由 struct class_device 来表示:</P><PRE class=programlisting>struct class_device {
struct kobject kobj;
struct class *class;
struct device *dev;
void *class_data;
char class_id[BUS_ID_SIZE];

 };
</PRE><P>class_id 成员持有设备名子, 如同它在 sysfs 中的一样. class 指针应当指向持有这个设备的类, 并且 dev 应当指向关联的设备结构. 设置 dev 是可选的; 如果它是非 NULL, 它用来创建一个符号连接从类入口到对应的在 /sys/devices 下的入口, 使得易于在用户空间找到设备入口. 类可以使用 class_data 来持有一个私有指针.</P><P>通常的注册函数已经被提供:</P><PRE class=programlisting>int class_device_register(struct class_device *cd);
void class_device_unregister(struct class_device *cd);
</PRE><P>类设备接口也允许重命名一个已经注册的入口:</P><PRE class=programlisting>int class_device_rename(struct class_device *cd, char *new_name); 
</PRE><P>类设备入口有属性:</P><PRE class=programlisting>struct class_device_attribute {
 struct attribute attr;
 ssize_t (*show)(struct class_device *cls, char *buf);
 ssize_t (*store)(struct class_device *cls, const char *buf,
 size_t count);
};

CLASS_DEVICE_ATTR(name, mode, show, store); 
int class_device_create_file(struct class_device *cls, const struct class_device_attribute *attr);
void class_device_remove_file(struct class_device *cls, const struct class_device_attribute *attr);
</PRE><P>一个缺省的属性集合, 在类的 class_dev_attrs 成员, 被创建当类设备被注册时; class_device_create_file 可用来创建额外的属性. 属性还可以被加入到由 class_simple 接口创建的类设备.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Classinterfaces.sect3></A>14.5.2.3.&nbsp;类接口</H4></DIV></DIV></DIV><P>类子系统有一个额外的在 Linux 设备模型其他部分找不到的概念. 这个机制称为一个接口, 但是它是, 也许, 最好作为一种触发机制可用来在设备进入或离开类时得到通知.</P><P>一个接口被表示, 使用:</P><PRE class=programlisting>struct class_interface {
 struct class *class;
 int (*add) (struct class_device *cd);
 void (*remove) (struct class_device *cd); 
}; 
</PRE><P>接口可被注册或注销, 使用:</P><PRE class=programlisting>int class_interface_register(struct class_interface *intf);
void class_interface_unregister(struct class_interface *intf);
</PRE><P>一个接口的功能是简单明了的. 无论何时一个类设备被加入到在 class_interface 结构中指定的类时, 接口的 add 函数被调用. 这个函数可进行任何额外的这个设备需要的设置; 这个设置常常采取增加更多属性的形式, 但是其他的应用都可能. 当设备被从类中去除, remove 方法被调用来进行任何需要的清理.</P><P>可注册多个接口给一个类.</P><P>&nbsp;</P><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=PuttingItAllTogether.sect1></A>14.6.&nbsp;集成起来</H2></DIV></DIV></DIV><P>为更好理解驱动模型做什么, 让我们通览一个设备在内核中的生命周期的阶段. 我们描述 PCI 子系统如何与驱动模型交互, 一个驱动如何被加入和去除的基本概念, 以及一个设备如何从系统中被加入和去除. 这些细节, 即便特别地描述 PCI 内核代码, 适用所有其他的使用驱动核心来管理它们的驱动和设备的子系统.</P><P>PCI 核心, 驱动核心和单独的 PCI 驱动之间的交互是非常复杂, 如同图 <A title=图&nbsp;14.3.&nbsp;创建设备过程 href="http://www.deansys.com/doc/ldd3/ch14s06.html#ldd3-14-3.fig"><FONT color=#0000ff>创建设备过程</FONT></A>所示.</P><DIV class=figure><A name=ldd3-14-3.fig></A><P class=title><B>图&nbsp;14.3.&nbsp;创建设备过程</B></P><DIV><IMG alt=创建设备过程 src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/ldd3-14-3.png"></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=AddaDevice.sect2></A>14.6.1.&nbsp;添加一个设备</H3></DIV></DIV></DIV><P>PCI 子系统声明一个单个 struct bus_type 称为 pci_bus_type, 它使用下列值初始化:</P><PRE class=programlisting>struct bus_type pci_bus_type = {
 .name  = "pci", 
 .match  = pci_bus_match, 
 .hotplug  = pci_hotplug, 
 .suspend  = pci_device_suspend, 
 .resume  = pci_device_resume, 
 .dev_attrs = pci_dev_attrs, };
</PRE><P>这个 pci_bus_type 变量被注册到驱动内核, 当 PCI 子系统通过对 bus_register 的调用被加载入内核时. 当这个发生时, 驱动核心创建一个 sysfs 目录在 /sys/bus/pci 里, 它包含 2 个目录: devices 和 drivers.</P><P>所有的 PCI 驱动必须定义一个 struct pci_driver 变量, 它定义了这个 PCI 驱动能够做的不同的功能(更多的关于 PCI 子系统和如何编写一个 PCI 驱动的信息, 见 12 章). 那个结构包含一个 struct device_driver, 它接着被 PCI 核心初始化, 当 PCI 驱动被注册时.</P><PRE class=programlisting>/* initialize common driver fields */
drv-&gt;driver.name = drv-&gt;name;
drv-&gt;driver.bus = &amp;pci_bus_type;
drv-&gt;driver.probe = pci_device_probe;
drv-&gt;driver.remove = pci_device_remove; 
drv-&gt;driver.kobj.ktype = &amp;pci_driver_kobj_type;
</PRE><P>这个代码为驱动建立总线来指向 pci_bus_type 以及使 probe 和 remove 函数来指向 PCI 核心内的函数. 驱动的 kobject 的 ktype 被设置为变量 pci_driver_kobj_type, 为使 PCI 驱动的属性文件正常工作. 接着 PCI 核心注册 PCI 驱动到驱动核心:</P><PRE class=programlisting>/* register with core */
error = driver_register(&amp;drv-&gt;driver);
</PRE><P>驱动现在准备好被绑定到任何一个它支持的 PCI 设备.</P><P>PCI 核心, 在来自特定结构的实际和 PCI 总线交谈的代码的帮助下, 开始探测 PCI 地址空间, 查找所有的 PCI 设备. 当一个PCI 设备被发现, PCI 核心在内存中创建一个 struct pci_dev 类型的新变量. struct pci_dev 结构的一部分看来如下:</P><PRE class=programlisting>struct pci_dev {
 /* ... */
 unsigned int devfn;
 unsigned short vendor;
 unsigned short device;
 unsigned short subsystem_vendor;
 unsigned short subsystem_device;
 unsigned int class;
 /* ... */
 struct pci_driver *driver;
 /* ... */
 struct device dev;
 /* ... */

}; 
</PRE><P>这个 PCI 设备的总线特定的成员被 PCI 核心初始化( devfn, vendor, device, 和其他成员), 并且 struct device 变量的 parent 变量被设置为这个 PCI 设备所在的 PCI 总线设备. bus 变量被设置指向 pci_bus_type 结构. 接下来 name 和 bus_id 变量被设置, 根据读自 PCI 设备的 name 和 ID.</P><P>在 PCI 设备结构被初始化之后, 设备被注册到驱动核心, 使用:</P><PRE class=programlisting>device_register(&amp;dev-&gt;dev); 
</PRE><P>在 device_register 函数中, 驱动核心初始化设备的许多成员, 注册设备的 kobject 到 kobject 核心( 它导致一个热插拔事件产生, 但是我们在本章后面讨论), 接着添加设备到驱动的 parent 所持有的设备列表中. 完成这个使所有的设备可被以正确的顺序浏览, 一直知道每一个位于设备层次中哪里.</P><P>设备接着被添加到所有设备的总线特定的列表中, 在本例中, pci_bus_type 列表. 接着注册到这个总线的所有驱动的列表被检查, 并且总线的匹配功能被调用给每个驱动, 指定这个设备. 对于 pci_bus_type 总线, 匹配函数被 PCI 核心设定为指向 pci_bus_match 函数, 在设备被提交给驱动核心前.</P><P>pci_bus_match 函数转换驱动核心传递给它的 struct device 为一个 struct pci_dev. 它还转换 struct device_driver 为一个 struct pci_driver , 并接着查看设备的 PCI 设备特定信息和驱动, 看是否这个驱动声明它能够支持这类设备. 如果匹配不成功, 函数返回 0 给驱动核心, 并且驱动核心移向列表中的下一个驱动.</P><P>如果匹配成功, 函数返回 1 给驱动核心. 这使驱动核心设置struct device 中的驱动指针指向这个驱动, 并且接着调用在 struct device_driver 中特定的 probe 函数.</P><P>早些时候, 在 PCI 驱动注册到驱动核心之前, probe 变量被设为指向 pci_device_probe 函数. 这个函数转换(又一次) struct device 为一个struct pci_dev, 在设备中设置的 struct driver 为一个 struct pci_driver. 它再次验证这个驱动声明它可以支持这个设备( 这意味着一个重复的额外检查, 某些未知的原因), 递增设备的引用计数, 并且接着调用 PCI 驱动的 probe 函数, 用一个指向它应当被绑定到的 struct pci_dev 结构的指针.</P><P>如果这个 PCI 驱动的 probe 函数认为它不能处理这个设备由于某些原因, 它返回一个负的错误值, 这个值被传递回驱动核心并且使它继续深入设备列表来和这个设备匹配一个. 如果这个 probe 函数能够认领这个设备, 它做所有的需要的初始化来正确处理这个设备, 并且接着它返回 0 给驱动核心. 这使驱动核心来添加设备到当前被这个特定驱动所绑定的所有设备列表, 并且创建一个符号连接到这个它现在控制的设备, 在这个驱动在 sysfs 的目录. 这个符号连接允许用户准确见到哪个设备被绑定到哪个设备. 这可被见到, 如:</P><PRE class=screen>$ tree /sys/bus/pci
/sys/bus/pci/
|-- devices
|  |-- 0000:00:00.0 -&gt; ../../../devices/pci0000:00/0000:00:00.0  
|  |-- 0000:00:00.1 -&gt; ../../../devices/pci0000:00/0000:00:00.1  
|  |-- 0000:00:00.2 -&gt; ../../../devices/pci0000:00/0000:00:00.2  
|  |-- 0000:00:02.0 -&gt; ../../../devices/pci0000:00/0000:00:02.0  
|  |-- 0000:00:04.0 -&gt; ../../../devices/pci0000:00/0000:00:04.0  
|  |-- 0000:00:06.0 -&gt; ../../../devices/pci0000:00/0000:00:06.0  
|  |-- 0000:00:07.0 -&gt; ../../../devices/pci0000:00/0000:00:07.0  
|  |-- 0000:00:09.0 -&gt; ../../../devices/pci0000:00/0000:00:09.0  
|  |-- 0000:00:09.1 -&gt; ../../../devices/pci0000:00/0000:00:09.1  
|  |-- 0000:00:09.2 -&gt; ../../../devices/pci0000:00/0000:00:09.2  
|  |-- 0000:00:0c.0 -&gt; ../../../devices/pci0000:00/0000:00:0c.0  
|  |-- 0000:00:0f.0 -&gt; ../../../devices/pci0000:00/0000:00:0f.0  
|  |-- 0000:00:10.0 -&gt; ../../../devices/pci0000:00/0000:00:10.0  
|  |-- 0000:00:12.0 -&gt; ../../../devices/pci0000:00/0000:00:12.0  
|  |-- 0000:00:13.0 -&gt; ../../../devices/pci0000:00/0000:00:13.0  
|  `-- 0000:00:14.0 -&gt; ../../../devices/pci0000:00/0000:00:14.0  
`-- drivers
 |-- ALI15x3_IDE
 | `-- 0000:00:0f.0 -&gt; ../../../../devices/pci0000:00/0000:00:0f.0
 |-- ehci_hcd
 | `-- 0000:00:09.2 -&gt; ../../../../devices/pci0000:00/0000:00:09.2
 |-- ohci_hcd
 | |-- 0000:00:02.0 -&gt; ../../../../devices/pci0000:00/0000:00:02.0
 | |-- 0000:00:09.0 -&gt; ../../../../devices/pci0000:00/0000:00:09.0
 | `-- 0000:00:09.1 -&gt; ../../../../devices/pci0000:00/0000:00:09.1
 |-- orinoco_pci
 | `-- 0000:00:12.0 -&gt; ../../../../devices/pci0000:00/0000:00:12.0
 |-- radeonfb
 | `-- 0000:00:14.0 -&gt; ../../../../devices/pci0000:00/0000:00:14.0
 |-- serial
 `-- trident
 `-- 0000:00:04.0 -&gt; ../../../../devices/pci0000:00/0000:00:04.0 
</PRE></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=RemoveaDevice.sect2></A>14.6.2.&nbsp;去除一个设备</H3></DIV></DIV></DIV><P>一个 PCI 可用多个不同的方法被从系统中去除. 所有的 card-bus 设备在一个不同的物理因素上是真正的 PCI 设备, 并且内核 PCI 核心不区分它们. 允许在机器运行时加减 PCI 设备的系统正变得更加普遍, 并且 Linux 支持它们. 还有一个伪 PCI 热插拔驱动允许开发者来测试看是否他们的 PCI 驱动正确处理系统运行中的设备去除. 这个模块称为 fakephp 并且使内核认为 PCI 设备已消失, 但是它不允许用户物理上从系统中去除一个 PCI 设备, 这个系统没有合适的硬件来这样做. 见这个驱动的文档来获取更多关于如何使用它测试你的 PCI 驱动的信息.</P><P>PCI 核心发挥了不少于它增加设备的努力到去除它. 当一个 PCI 设备要被去除, pci_remove_bus_device 函数被调用. 这个函数做一些 PCI-特定 的清理和日常工作, 并且接着使用一个指向 struct pci_dev 的 struct device 成员的指针调用 device_unregister 函数.</P><P>在 device_unregister 函数中, 驱动核心只从绑定到这个设备(如果有)的驱动解除连接 sysfs 文件, 从它的内部设备列表中去除这个设备, 并且使用指向包含在 struct device 结构中的 struct kobject 的指针调用 kobject_del. 这个函数用一个 hotplug 调用到用户空间来声明 kobject 现在被从系统中去除, 并且接着它删除所有的和 kobject 关联的 sysfs 文件以及这个 kobject 起初已创建的 sysfs 目录自身.</P><P>kobject_del 函数也去除设备自身的 kobject 引用. 如果那个引用是最后一个( 意味着没有用户空间文件为这个 sysfs 的设备入口而打开 ), 接着是 PCI 设备自身的 release 函数, pci_release_dev, 被调用. 这个函数只释放 struct pci_dev 占用的内存.</P><P>此后, 所有的和这个设备关联的 sysfs 入口被去除, 并且和这个设备关联的内存被释放. PCI 设备现在完全从系统中被去除.</P></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=AddaDriver.sect2></A>14.6.3.&nbsp;添加一个驱动</H3></DIV></DIV></DIV><P>一个 PCI 驱动被添加到 PCI 核心, 当它调用 pci_register_driver 函数时. 这个函数只初始化 struct device_driver 结构, 这个结构包含在 struct pci_driver 结构里面, 如同之前在关于添加设备的一节中提过的. 接着 PCI 核心使用指向包含在 struct pci_driver 结构中的 sturct device_driver 结构的指针调用在驱动核心的 driver_register 函数.</P><P>driver_register 函数初始化在 struct device_driver 结构中的几个锁, 并且接着调用 bus_add_driver 函数. 这个函数进行下面的步骤:</P><DIV class=itemizedlist><UL type=disc><LI><P>查找驱动要被关联的总线. 如果这个总线被发现, 函数立刻返回.</P><LI><P>驱动的 sysfs 目录被创建, 基于驱动的名子和它被关联的总线.</P><LI><P>总线的内部锁被获取, 接着所有的已经注册到总线的设备被检查, 匹配函数为它们被调用, 就象当一个新设备被添加时. 如果那个匹配函数成功, 接着剩下的绑定过程发生, 如同在前面章节描述过的.</P></LI></UL></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=RemoveaDriver.sect2></A>14.6.4.&nbsp;去除一个驱动</H3></DIV></DIV></DIV><P>去除一个驱动是一个非常容易的动作. 对于一个 PCI 驱动, 驱动调用 pci_unregister_driver 函数. 这个函数只调用驱动核心函数 driver_unregister, 使用一个指向传递给它的 struct pci_driver 的 struct devie_driver 的指针.</P><P>deiver_unregister 函数处理一些基本的日常工作, 通过清理某些在 sysfs 树中连接到这个驱动入口的 sysfs 属性. 它接着列举所有的连接到这个驱动的设备并且为它调用 release 函数. 发生这个恰好象前面提过的 release 函数, 当一个设备从系统中去除时.</P><P>在所有的设备从驱动中被解绑定后, 驱动代码完成这个独特的逻辑:</P><PRE class=programlisting>down(&amp;drv-&gt;unload_sem);
up(&amp;drv-&gt;unload_sem);
</PRE><P>这就在返回函数的调用者之前完成. 这个锁被获取因为代码需要等待所有的对这个驱动的引用计数在它可安全返回前掉到 0. 需要这样是因为 driver_unregister 函数最普遍被作为一个要卸载的模块退出的路径来调用. 模块需要保留在内存只要驱动被设备引用并且等待这个锁被释放, 这允许内核知道当可以安全从内存去除驱动时.</P><P>&nbsp;</P><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=Hotplug.sect1></A>14.7.&nbsp;热插拔</H2></DIV></DIV></DIV><P>有 2 个不同方法来看热插拔. 内核看待热插拔为硬件, 内核和内核驱动之间的交互. 用户看待热插拔是内核和用户空间的通过称为 /sbin/hotplug 的程序的交互. 这个程序被内核调用, 当它想通知用户空间某种热插拔事件刚刚在内核中发生.</P><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=DynamicDevices.sect2></A>14.7.1.&nbsp;动态设备</H3></DIV></DIV></DIV><P>术语"热插拔"最普遍使用的意义产生于当讨论这样的事实时, 几乎所有的计算机系统现在能够处理当系统有电时设备的出现或消失. 这非常不同于只是几年前的计算机系统, 那时程序员知道他们只需要在启动时扫描所有的设备, 并且他们从不必担心他们的设备消失直到整个机器被关电. 现在, 随着 USB 的出现, CardBus, PCMCIA, IEEE1394, 和 PCI 热插拔控制器, Linux 内核需要能够可靠地运行不管什么硬件从系统中增加或去除. 这产生了一个额外的负担给设备驱动作者, 因为现在他们必须一直处理一个没有任何通知而突然从地下冒出来的设备.</P><P>每个不同的总线类型以不同方式处理一个设备的消失. 例如, 当一个 PCI , CardBus, 或者 PCMCIA 设备从系统中去除, 在驱动通过它的去除函数被通知之前常常是一会儿. 在发生这个前, 所有的从 PCI 的读返回所有的位集合. 这意味着驱动需要一直检查它们从 PCI 总线读取的值并且能够正确处理 0xff 值.</P><P>这个的一个例子可在 drivers/usb/host/ehci-hcd.c 驱动中见到, 它是一个 PCI 驱动给一个 UBS 2.0(高速)控制卡. 它有下面的代码在它的主握手循环中来探测是否控制块已经从系统中去除.</P><PRE class=programlisting>result = readl(ptr);
if (result == ~(u32)0)  /* card removed */
 return -ENODEV; 
</PRE><P>对于 USB 驱动, 当一个 USB 驱动被绑定到的设备被从系统中去除, 任何挂起的已被提交给设备的 urbs 以错误 -ENODEV 失败. 如果发生这个情况, 驱动需要识别这个错误并且正确清理任何挂起的 I/O .</P><P>可热插拔的设备不只限于传统的设备, 例如鼠标, 键盘, 和网卡. 有大量的系统现在支持整个 CPU 和内存条的移出. 幸运地, Linux 内核正确处理这些核心"系统"设备的加减, 以至于单个设备驱动不需要注意这些事情.</P></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=ThesbinhotplugUtility.sect2></A>14.7.2.&nbsp;/sbin/hotplug 工具</H3></DIV></DIV></DIV><P>如同本章中前面提过的, 无论何时一个设备从系统中增删, 都产生一个"热插拔事件". 这意味着内核调用用户空间程序 /sbin/hotplug. 这个程序典型地是一个非常小的 bash 脚本, 只传递执行给一系列其他的位于 /etc/hot-plug.d/ 目录树的程序. 对于大部分的 Linux 发布, 这个脚本看来如下:</P><PRE class=screen>DIR="/etc/hotplug.d"
for I in "${DIR}/$1/"*.hotplug "${DIR}/"default/*.hotplug ; do
 if [ -f $I ]; then
 test -x $I &amp;&amp; $I $1 ;
 fi
done
exit 1
</PRE><P>换句话说, 这个脚本搜索所有的有 .hotplug 后缀的可能对这个事件感兴趣的程序并调用它们, 传递给它们许多不同的环境变量, 这些环境变量已经被内核设置. 更多关于 /sbin/hotplug 脚本如何工作的细节可在程序的注释中找到, 以及在 hotplug(8)手册页中.</P><P>如同前面提到的, /sbin/hotplug 被调用无论何时一个 kobject 被创建或销毁. 热插拔程序被用一个提供事件名子的单个命令行参数调用. 核心内核和涉及到的特定子系统也设定一系列带有关于发生了什么的信息的环境变量(下面描述). 这些变量被热插拔程序使用来判定刚刚在内核发生了什么, 以及是否有任何特定的动作应当采取.</P><P>传递给 /sbin/hotplug 的命令行参数是关联这个热插拔事件的名子, 如同分配给 kobject 的 kset 所决定的. 这个名子可通过一个对属于本章前面描述过的 kset 的 hotplug_ops 结构的 name 函数的调用来设定; 如果那个函数不存在或者从未被调用, 名子是 kset 自身的名子.</P><P>一直为 /sbin/hotplug 设定的缺省的环境变量是:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>ACTION </SPAN></SPAN><DD><P>这个字符串 add 或 remove, 只根据是否这个对象是被创建或者销毁.</P><DT><SPAN class=term><SPAN>DEVPATH </SPAN></SPAN><DD><P>一个目录路径, 在 sysfs 文件系统中, 它指向在被创建或销毁的 kobject. 注意 sysfs 文件系统的加载点不是添加到这路径, 因此是由用户空间程序来决定这个. </P><DT><SPAN class=term><SPAN>SEQNUM </SPAN></SPAN><DD><P>这个热插拔事件的顺序号. 顺序号是一个 64-位 数, 它每次产生热插拔事件都递增. 这允许用户空间以内核产生它们的顺序来排序热插拔事件, 因为对一个用户空间程序可能乱序运行.</P><DT><SPAN class=term><SPAN>SUBSYSTEM </SPAN></SPAN><DD><P>同样的字符串作为前面描述的命令行参数传递.</P></DD></DL></DIV><P>许多不同的总线子系统都添加它们自己的环境变量到 /sbin/hotplug 调用中, 当关联到总线的设备被添加或从系统中去除. 它们在它们的热插拔回调中做这个, 这个回调在分配给它们的总线(如同在"热插拔操作"一节中描述的)的 struct kset_hotplug_ops 中指定. 这允许用户空间能够自动加载必要的可能需要来控制这个被总线发现的设备的模块. 这里是一个不同总线类型的列表以及它们添加到 /sbin/hotplug 调用中的环境变量. </P><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=IEEE1394FireWire.sect3></A>14.7.2.1.&nbsp;IEEE1394(火线)</H4></DIV></DIV></DIV><P>任何在 IEEE1394 总线, 也是火线, 上的设备, 由 /sbin/hotplug 参数名和 SUBSYSTEM 环境变量设置为值 ieee1394. ieee1394 子系统也总是添加下列 4 个环境变量:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>VENDOR_ID </SPAN></SPAN><DD><P>IEEE1394 的 24-位 供应者 ID. </P><DT><SPAN class=term><SPAN>MODEL_ID </SPAN></SPAN><DD><P>IEEE1394 的 24-位型号 ID.</P><DT><SPAN class=term><SPAN>GUID </SPAN></SPAN><DD><P>设备的 64-位 GUID.</P><DT><SPAN class=term><SPAN>SPECIFIER_ID </SPAN></SPAN><DD><P>24-位值, 指定设备的协议规格的拥有者.</P><DT><SPAN class=term><SPAN>VERSION </SPAN></SPAN><DD><P>指定设备协议规格的版本的值</P></DD></DL></DIV></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Networking.sect3></A>14.7.2.2.&nbsp;网络</H4></DIV></DIV></DIV><P>所有的网络设备都创建一个热插拔事件, 当设备注册或者注销在内核. /sbin/hotplug 调用有参数 name 和 SUBSYSTEM 环境变量设置为 net, 并且只添加下列环境变量:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>INTERFACE </SPAN></SPAN><DD><P>已经从内核注册或注销的接口的名子. 这个的例子是 lo 和 eth0.</P></DD></DL></DIV></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=PCI.sect3></A>14.7.2.3.&nbsp;PCI 总线</H4></DIV></DIV></DIV><P>任何在 PCI 总线上的设备有参数 name 和 SUBSYSTEM 环境变量设置为值 pci. PCI 子系统也一直添加下面 4 个环境变量:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>PCI_CLASS </SPAN></SPAN><DD><P>设备的 PCI 类号, 16 进制.</P><DT><SPAN class=term><SPAN>PCI_ID </SPAN></SPAN><DD><P>设备的 PCI 供应商和设备 ID, 16进制, 结合成这样的格式 供应者:设备.</P><DT><SPAN class=term><SPAN>PCI_SUBSYS_ID </SPAN></SPAN><DD><P>PCI 子系统供应商和子系统设备 ID, 以 子系统供应者:子系统设备 的格式结合.</P><DT><SPAN class=term><SPAN>PCI_SLOT_NAME </SPAN></SPAN><DD><P>PCI 插口"名", 内核给予这个设备的. 它以这样的格式 域:总线:插口:功能. 一个例子可能是: 0000:00:0d.0.</P></DD></DL></DIV></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Input.sect3></A>14.7.2.4.&nbsp;输入</H4></DIV></DIV></DIV><P>对所有的输入设备(鼠标, 键盘, 游戏杆, 等等), 一个热插拔事件当设备从内核增减时产生. /sbin/hotplug 参数和 SUBSYSTEM 环境变量被设置为值 input. 输入子系统也总是添加下面的环境变量:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>PRODUCT </SPAN></SPAN><DD><P>一个多值字符串, 用 16 进制列出值没有前导 0. 它的格式是 bustype:vender:product:version.</P></DD></DL></DIV><P>下列环境变量可能出现, 如果设备支持它:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>NAME </SPAN></SPAN><DD><P>输入设备的名子, 如同设备给定的.</P><DT><SPAN class=term><SPAN>PHYS </SPAN></SPAN><DD><P>输入子系统给这个设备的设备的物理地址. 它假定是稳定的, 依赖设备所插入的总线的位置.</P><DT><SPAN class=term><SPAN>EV</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>KEY</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>REL</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>ABS</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>MSC</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>LED</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>SND</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>FF </SPAN></SPAN><DD><P>这些都来自输入设备描述符并且被设置为合适的值如果特定的输入设备支持它.</P></DD></DL></DIV></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=USB.sect3></A>14.7.2.5.&nbsp;USB 总线</H4></DIV></DIV></DIV><P>任何在 USB 总线上的设备有参数 name 和 SUBSYSTEM 环境变量设置为 usb. USB 子系统也总是一直添加下列的环境变量:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>PRODUCT </SPAN></SPAN><DD><P>一个字符串, idVendor/idProduct/bcdDevice 的格式, 来指定这些 USB 设备特定的成员.</P><DT><SPAN class=term><SPAN>TYPE </SPAN></SPAN><DD><P>一个 bDeviceClass/bDeviceSubClass/bDeviceProtocol 格式的字符串, 指定这些 USB 设备特定的成员.</P></DD></DL></DIV><P>如果 bDeviceClass 成员设置为 0, 下列的环境变量也被设置:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>INTERFACE </SPAN></SPAN><DD><P>一个 bInterfaceClass/bInterfaceSubClass/bInterfaceProtocol 格式的字符串, 指定这些 USB 设备特定成员.</P></DD></DL></DIV><P>如果这个内核建立选项, CONFIG_USB_DEVICEFS, 它选择 usbfs 文件系统来在内核中建立, 被选中, 下列环境变量也被设置:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>DEVICE </SPAN></SPAN><DD><P>一个字符串, 在设备所在的 usbfs 文件系统中出现. 这个字串以 /proc/bus/usb/USB_BUS_NUMBER/USB_DEVICE_NUMBER 的格式, 其中 USB_BUS_NUMBER 是这个设备所在的 USB 总线的 3 个数, USB_DEVICE_NUMBER 是已由内核分配给 USB 设备的 3 位数.</P></DD></DL></DIV></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=SCSI.sect3></A>14.7.2.6.&nbsp;SCSI 总线</H4></DIV></DIV></DIV><P>所有的 SCSI 设备创建一个热插拔事件当 SCSI 设备从内核中创建或去除. /sbin/hotplug 调用有参数 name 和 SUBSYSTEM 环境变量设置为 scsi 给每个添加或去除自系统的 SCSI 设备. 没有额外的环境变量由 SCSI 系统添加, 但是它被在此提及因为有一个 SCSI 特定的用户空间脚本来决定什么 SCSI 驱动( 磁盘, 磁带, 通用, 等等)应当给这个特定 SCSI 设备加载.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Laptopdockingstations.sect3></A>14.7.2.7.&nbsp;膝上电脑坞站</H4></DIV></DIV></DIV><P>如果一个支持即插即用的膝上电脑坞站被从运行中的 Linux 系统中添加或去除( 通过插入膝上电脑到坞站中, 或者去除它), 一个热插拔事件被产生. /sbin/hotplug 调用有参数 name 和 SUBSYSTEM 环境变量设为 dock. 没有其他的环境变量被设置.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=S390andzSeries.sect3></A>14.7.2.8.&nbsp;S/390 和 zSeries</H4></DIV></DIV></DIV><P>在 S/390 体系中, 通道总线结构支持很广范围的硬件, 所有产生 /sbin/hotplug 事件当它们从 Linux 虚拟系统被添加或去除时的硬件. 这些设备都有 /sbin/hotplug 参数 name 和 SUBSYSTEM 环境变量设置为 dasd. 没有其他环境变量被设置.</P></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=Usingsbinhotplug.sect2></A>14.7.3.&nbsp;使用 /sbin/hotplug </H3></DIV></DIV></DIV><P>现在 Linux 内核在调用 /sbin/hotplug 为每个设备, 添加和删除自内核, 许多非常有用的工具在用户空间已被创建来利用这一点. 2 个最常用的工具是 Linux 热插拔脚本和 udev.</P><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=Linuxhotplugscripts.sect3></A>14.7.3.1.&nbsp;Linux 热插拔脚本</H4></DIV></DIV></DIV><P>Linux 热插拔脚本作为 /sbin/hotplug 调用的第一个用户而启动. 这些脚本查看内核设置的来描述刚刚发现的设备的不同的环境变量, 并接着试图发现一个匹配这个设备的内核模块.</P><P>如同前面描述的, 当一个驱动使用 MODULE_DEVICE_TABLE 宏, 程序 depmod 采用这个信息并创建位于 /lib/module/KERNEL_VERSION/modules.*map 的文件. 这个 * 是不同的, 根据驱动支持的总线类型. 当前, 模块 map 文件为使用设备的驱动而产生, 这些设备支持 PCI, USB, IEEE1394, INPUT, ISAPNP, 和 CCW 子系统.</P><P>热插拔脚本使用这些模块映射文本文件, 来决定试图加载什么模块来支持内核刚刚发现的设备. 它们加载所有的模块, 在第一次匹配时不停止, 为了使内核发现那个模块工作得最好. 这些脚本不加载任何模块当驱动被去除时. 如果它们要试图做这个, 它们可能偶然地关闭被同一个要被去除的驱动控制的设备.</P><P>注意, 现在 modprobe 程序能直接从模块中读 MODULE_DEVICE_TABLE 信息而不需要模块 map 文件, 热插拔脚本可能被删减为一个小的在 modprobe 程序周围的包装.</P></DIV><DIV class=sect3 lang=zh-cn><DIV class=titlepage><DIV><DIV><H4 class=title><A name=udev.sect3></A>14.7.3.2.&nbsp;udev 啥?</H4></DIV></DIV></DIV><P>在内核中创建统一的驱动模型的一个主要原因是允许用户空间动态管理 /dev 树. 这之前已使用 devfs 的实现在用户空间实现, 但是那个代码底线已慢慢消失, 由于缺少一个活跃的维护者以及一些无法修正的核心 bug. 许多内核开发者认识到如果所有的设备信息被输出给用户空间, 它可能进行所有的必要的 /dev 树的管理.</P><P>devfs 在它的设计中有一些非常基础的缺陷. 它需要每个设备驱动被修改来支持它, 并且它要求设备驱动来指定名子和在它所在的 /dev 树中的位置. 它也没有正确处理动态主次编号, 并且它不允许用户空间以简单方式覆盖设备的命名, 这样来强制设备命名策略于内核中而不是在用户空间. Linux 内核开发中非常厌恶使策略在内核中, 并且因为 devfs 命名策略不遵循 Linux 标准基础规格, 它确实困扰他们.</P><P>随着 Linux 内核开始安装到大型服务器, 许多用户遇到如何管理大量设备的问题. 超过 10,000 个单一设备的磁盘驱动阵列提出了非常困难的任务, 保证一个特定磁盘一直使用相同的名子命名, 不管它在磁盘阵列的哪里或者它什么时候被内核发现. 同样的问题也折磨着桌面用户, 想插入 2 个 USB 打印机到他们的系统, 并且接着发现它们没有办法保证已知为 /dev/lpt0 的打印机不会改变并分配给其他的打印机如果系统重启.</P><P>因此, udev 被创建. 它依靠所有通过 sysfs 输出给用户空间的设备信息, 并且依靠被 /sbin/hotplug 通知有设备添加或去除. 策略决策, 例如给一个设备什么名子, 可在用户空间指定, 内核之外. 这保证了命名策略被从内核中去除并且允许大量每个设备名子的灵活性.</P><P>对更多的关于如何使用 udev 和如何配置它的信息, 请看在你的发布中和 udev 软件包一起的文档.</P><P>所有的一个设备驱动需要做的, 为 udev 正确使用它, 是确保任何分配给一个驱动控制的设备的主次编号通过 sysfs 输出到用户空间. 对任何使用一个子系统来安排它一个主次编号的驱动, 这已经由子系统完成, 并且驱动不必做任何工作. 做这个的子系统的例子是 tty, misc, usb, input, scsi, block, i2c, network, 和 frame buffer 子系统. 如果你的驱动自己获得一个主次编号, 通过对 cdev_init 函数的调用或者更老的 register_chrdev 函数, 驱动需要被修改以便 udev 能够正确使用它.</P><P>udev 查找一个称为 dev 的文件在 sysfs 的 /class/ 树中, 为了决定分配什么主次编号给一个特定设备当它被内核通过 /sbin/hotplug 接口调用时. 一个设备驱动只要为每个它控制的设备创建这个文件. class_simple 接口常常是最易的做这个的方法.</P><P>如同" class_simple 接口"一节中提过的, 使用 class_simple 接口的第一步是调用 class_simple_create 函数来创建一个 struct class_simple.</P><PRE class=programlisting>static struct class_simple *foo_class;
...
foo_class = class_simple_create(THIS_MODULE, "foo");
if (IS_ERR(foo_class)) {
 printk(KERN_ERR "Error creating foo class.\n");
 goto error;
}
</PRE><P>这个代码创建一个目录在 sysfs 中 /sys/class/foo.</P><P>无论何时你的驱动发现一个新设备, 并且你如第 3 章描述的分配它一个次编号, 驱动应当调用 class_simple_device_add 函数:</P><PRE class=programlisting>class_simple_device_add(foo_class, MKDEV(FOO_MAJOR, minor), NULL, "foo%d", minor); 
</PRE><P>这个代码导致在 /sys/class/foo 创建一个子目录称为 fooN, 这里 N 是这个设备的次编号. 在这个目录里创建有一个文件, dev, 它恰好是 udev 为你的设备创建一个设备节点需要的.</P><P>当你的驱动从一个设备解除, 并且你放弃它所依附的次编号, 需要调用 class_simple_device_remove 来去除这个设备的 sysfs 入口.</P><PRE class=programlisting>class_simple_device_remove(MKDEV(FOO_MAJOR, minor)); 
</PRE><P>之后, 当你的整个驱动被关闭, 需要调用 class_simple_destroy 来去除你起初调用 class_simple_create 创建的 class.</P><PRE class=programlisting>class_simple_destroy(foo_class); 
</PRE><P>同样 class_simple_device_add 创建的 dev 文件包括主次编号, 由一个 : 隔开. 如果你的驱动不想使用 class_simple 接口因为你想提供其他在子系统的类目录中的文件, 使用 print_dev_t 函数来正确格式化特定设备的主次编号.</P><P>&nbsp;</P><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=DealingwithFirmware.sect1></A>14.8.&nbsp;处理固件</H2></DIV></DIV></DIV><P>作为一个驱动作者, 你可能发现你面对一个设备必须在它能支持工作前下载固件到它里面. 硬件市场的许多地方的竞争是如此得强烈, 以至于甚至一点用作设备控制固件的 EEPROM 的成本制造商都不愿意花费. 因此固件发布在随硬件一起的一张 CD 上, 并且操作系统负责传送固件到设备自身.</P><P>你可能想解决固件问题使用这样的一个声明:</P><PRE class=programlisting>static char my_firmware[] = { 0x34, 0x78, 0xa4, ... }; 
</PRE><P>但是, 这个方法几乎肯定是一个错误. 将固件编码到一个驱动扩大了驱动的代码, 使固件升级困难, 并且非常可能产生许可问题. 供应商不可能已经发布固件映象在 GPL 之下, 因此和 GPL-许可的代码混合常常是一个错误. 为此, 包含内嵌固件的驱动不可能被接受到主流内核或者被 Linux 发布者包含.</P><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=TheKernelFirmwareInterface.sect2></A>14.8.1.&nbsp;内核固件接口</H3></DIV></DIV></DIV><P>正确的方法是当你需要它时从用户空间获取它. 但是, 请抵制试图从内核空间直接打开包含固件的文件的诱惑; 那是一个易出错的操作, 并且它安放了策略(以一个文件名的形式)到内核. 相反, 正确的方法时使用固件接口, 它就是为此而创建的:</P><PRE class=programlisting>#include &lt;linux/firmware.h&gt;
int request_firmware(const struct firmware **fw, char *name, 
 struct device *device); 
</PRE><P>调用 request_firmware 要求用户空间定位并提供一个固件映象给内核; 我们一会儿看它如何工作的细节. name 应当标识需要的固件; 正常的用法是供应者提供的固件文件名. 某些象 my_firmware.bin 的名子是典型的. 如果固件被成功加载, 返回值是 0(负责常用的错误码被返回), 并且 fw 参数指向一个这些结构:</P><PRE class=programlisting>struct firmware {
 size_t size;
 u8 *data; 
}; 
</PRE><P>那个结构包含实际的固件, 它现在可被下载到设备中. 小心这个固件是来自用户空间的未被检查的数据; 你应当在发送它到硬件之前运用任何并且所有的你能够想到的检查来说服你自己它是正确的固件映象. 设备固件常常包含标识串, 校验和, 等等; 在信任数据前全部检查它们.</P><P>在你已经发送固件到设备前, 你应当释放 in-kernel 结构, 使用:</P><PRE class=programlisting>void release_firmware(struct firmware *fw); 
</PRE><P>因为 request_firmware 请求用户空间来帮忙, 它保证在返回前睡眠. 如果你的驱动当它必须请求固件时不在睡眠的位置, 异步的替代方法可能要使用:</P><PRE class=programlisting>int request_firmware_nowait(struct module *module,
 char *name, struct device *device, void *context,
 void (*cont)(const struct firmware *fw, void *context)); 
</PRE><P>这里额外的参数是 moudle( 它将一直是 THIS_MODULE), context (一个固件子系统不使用的私有数据指针), 和 cont. 如果都进行顺利, request_firmware_nowait 开始固件加载过程并且返回 0. 在将来某个时间, cont 将用加载的结果被调用. 如果由于某些原因固件加载失败, fw 是 NULL.</P></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=HowItWorks.sect2></A>14.8.2.&nbsp;它如何工作</H3></DIV></DIV></DIV><P>固件子系统使用 sysfs 和热插拔机制. 当调用 request_firmware, 一个新目录在 /sys/class/firmware 下使用你的驱动的名子被创建. 那个目录包含 3 个属性:</P><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>loading </SPAN></SPAN><DD><P>这个属性应当被加载固件的用户空间进程设置为 1. 当加载进程完成, 它应当设为 0. 写一个值 -1 到 loading 会中止固件加载进程.</P><DT><SPAN class=term><SPAN>data </SPAN></SPAN><DD><P>data 是一个二进制的接收固件数据自身的属性. 在设置 loading 后, 用户空间进程应当写固件到这个属性.</P><DT><SPAN class=term><SPAN>device </SPAN></SPAN><DD><P>这个属性是一个符号连接到 /sys/devices 下面的被关联入口项.</P></DD></DL></DIV><P>一旦创建了 sysfs 入口项, 内核为你的设备产生一个热插拔事件. 传递给热插拔处理者的环境包括一个变量 FIRMWARE, 它被设置为提供给 request_firmware 的名子. 这个处理者应当定位固件文件, 并且拷贝它到内核使用提供的属性. 如果这个文件无法找到, 处理者应当设置 loading 属性为 -1.</P><P>如果一个固件请求在 10 秒内没有被服务, 内核就放弃并返回一个失败状态给驱动. 超时周期可通过 sysfs 属性 /sys/class/firmware/timeout 属性改变.</P><P>使用 request_firmware 接口允许你随你的驱动发布设备固件. 当正确地集成到热插拔机制, 固件加载子系统允许设备简化工作"在盒子之外" 显然这是处理问题的最好方法.</P><P>但是, 请允许我们提出多一条警告: 设备固件没有制造商的许可不应当发布. 许多制造商会同意在合理的条款下许可它们的固件, 如果客气地请求; 一些其他的可能不何在. 无论如何, 在没有许可时拷贝和发布它们的固件是对版权法的破坏并且招致麻烦.</P><P>&nbsp;</P><DIV class=sect1 lang=zh-cn><DIV class=titlepage><DIV><DIV><H2 class=title style="CLEAR: both"><A name=TheLinuxDeviceModelqr.sect1></A>14.9.&nbsp;快速参考</H2></DIV></DIV></DIV><P>许多函数在本章中已经被介绍过; 这是它们全部的一个快速总结.</P><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=Kobjects.sect2></A>14.9.1.&nbsp;Kobjects结构</H3></DIV></DIV></DIV><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>#include &lt;linux/kobject.h&gt;</SPAN></SPAN> <DD><P>包含文件, 包含 kobject 的定义, 相关结构, 和函数.</P><DT><SPAN class=term><SPAN>void kobject_init(struct kobject *kobj);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int kobject_set_name(struct kobject *kobj, const char *format, ...);</SPAN></SPAN> <DD><P>用作 kobject 初始化的函数</P><DT><SPAN class=term><SPAN>struct kobject *kobject_get(struct kobject *kobj);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void kobject_put(struct kobject *kobj);</SPAN></SPAN> <DD><P>为 kobjects 管理引用计数的函数.</P><DT><SPAN class=term><SPAN>struct kobj_type;</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>struct kobj_type *get_ktype(struct kobject *kobj);</SPAN></SPAN> <DD><P>表示一个kobjct 被嵌入的结构类型. 使用 get_ktype 来获得关联到一个给定 kobject 的 kobj_type.</P><DT><SPAN class=term><SPAN>int kobject_add(struct kobject *kobj);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>extern int kobject_register(struct kobject *kobj);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void kobject_del(struct kobject *kobj);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void kobject_unregister(struct kobject *kobj);</SPAN></SPAN> <DD><P>kobject_add 添加一个 kobject 到系统, 处理 kset 成员关系, sysfs 表示, 以及热插拔事件产生. kobject_register 是一个方便函数, 它结合 kobject_init 和 kobject_add. 使用 kobject_del 来去除一个 kobject 或者 kobject_unregister, 它结合了 kobject_del 和 kobject_put.</P><DT><SPAN class=term><SPAN>void kset_init(struct kset *kset);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int kset_add(struct kset *kset);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int kset_register(struct kset *kset);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void kset_unregister(struct kset *kset);</SPAN></SPAN> <DD><P>为 ksets 初始化和注册的函数.</P><DT><SPAN class=term><SPAN>decl_subsys(name, type, hotplug_ops);</SPAN></SPAN> <DD><P>易于声明子系统的一个宏.</P><DT><SPAN class=term><SPAN>void subsystem_init(struct subsystem *subsys);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int subsystem_register(struct subsystem *subsys);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void subsystem_unregister(struct subsystem *subsys);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>struct subsystem *subsys_get(struct subsystem *subsys);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void subsys_put(struct subsystem *subsys);</SPAN></SPAN> <DD><P>对子系统的操作.</P></DD></DL></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=SysfsOperations.sect2></A>14.9.2.&nbsp;sysfs 操作</H3></DIV></DIV></DIV><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>#include &lt;linux/sysfs.h&gt;</SPAN></SPAN> <DD><P>包含 sysfs 声明的包含文件.</P><DT><SPAN class=term><SPAN>int sysfs_create_file(struct kobject *kobj, struct attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int sysfs_remove_file(struct kobject *kobj, struct attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int sysfs_create_bin_file(struct kobject *kobj, struct bin_attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int sysfs_remove_bin_file(struct kobject *kobj, struct bin_attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int sysfs_create_link(struct kobject *kobj, struct kobject *target, char *name);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void sysfs_remove_link(struct kobject *kobj, char *name);</SPAN></SPAN> <DD><P>创建和去除和一个 kobject 关联的属性文件的函数.</P></DD></DL></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=BusesDevicesandDrivers.sect2></A>14.9.3.&nbsp;总线, 设备, 和驱动</H3></DIV></DIV></DIV><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>int bus_register(struct bus_type *bus);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void bus_unregister(struct bus_type *bus);</SPAN></SPAN> <DD><P>在设备模型中进行注册和注销总线的函数.</P><DT><SPAN class=term><SPAN>int bus_for_each_dev(struct bus_type *bus, struct device *start, void *data, int (*fn)(struct device *, void *));</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int bus_for_each_drv(struct bus_type *bus, struct device_driver *start, void *data, int (*fn)(struct device_driver *, void *));</SPAN></SPAN> <DD><P></P>列举每个设备和驱动的函数, 特别地, 绑定到给定总线的设备. <DT><SPAN class=term><SPAN>BUS_ATTR(name, mode, show, store);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int bus_create_file(struct bus_type *bus, struct bus_attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void bus_remove_file(struct bus_type *bus, struct bus_attribute *attr);</SPAN></SPAN> <DD><P>BUS_ATTR 宏可能用来声明一个 bus_attribute 结构, 它可能接着被添加和去除, 使用上面 2 个函数.</P><DT><SPAN class=term><SPAN>int device_register(struct device *dev);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void device_unregister(struct device *dev);</SPAN></SPAN> <DD><P>处理设备注册的函数.</P><DT><SPAN class=term><SPAN>DEVICE_ATTR(name, mode, show, store);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int device_create_file(struct device *device, struct device_attribute *entry);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void device_remove_file(struct device *dev, struct device_attribute *attr);</SPAN></SPAN> <DD><P>处理设备属性的宏和函数.</P><DT><SPAN class=term><SPAN>int driver_register(struct device_driver *drv);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void driver_unregister(struct device_driver *drv);</SPAN></SPAN> <DD><P>注册和注销一个设备驱动的函数.</P><DT><SPAN class=term><SPAN>DRIVER_ATTR(name, mode, show, store);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int driver_create_file(struct device_driver *drv, struct driver_attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void driver_remove_file(struct device_driver *drv, struct driver_attribute *attr);</SPAN></SPAN> <DD><P>关联驱动属性的宏和函数.</P></DD></DL></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=Classes.sect2></A>14.9.4.&nbsp;类</H3></DIV></DIV></DIV><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>struct class_simple *class_simple_create(struct module *owner, char *name);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void class_simple_destroy(struct class_simple *cs);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>struct class_device *class_simple_device_add(struct class_simple *cs, dev_t devnum, struct device *device, const char *fmt, ...);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void class_simple_device_remove(dev_t dev);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int class_simple_set_hotplug(struct class_simple *cs, int (*hotplug)(struct class_device *dev, char **envp, int num_envp, char *buffer, int buffer_size));</SPAN></SPAN> <DD><P>实现 class_simple 接口的函数; 它们管理包含一个 dev 属性和很少其他属性的简单的类入口</P><DT><SPAN class=term><SPAN>int class_register(struct class *cls);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void class_unregister(struct class *cls);</SPAN></SPAN> <DD><P>注册和注销类.</P><DT><SPAN class=term><SPAN>CLASS_ATTR(name, mode, show, store);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int class_create_file(struct class *cls, const struct class_attribute *attr);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void class_remove_file(struct class *cls, const struct class_attribute *attr);</SPAN></SPAN> <DD><P>处理类属性的常用宏和函数.</P><DT><SPAN class=term><SPAN>int class_device_register(struct class_device *cd);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void class_device_unregister(struct class_device *cd);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int class_device_rename(struct class_device *cd, char *new_name);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>CLASS_DEVICE_ATTR(name, mode, show, store);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int class_device_create_file(struct class_device *cls, const struct class_device_attribute *attr);</SPAN></SPAN> <DD><P>属性类设备接口的函数和宏.</P><DT><SPAN class=term><SPAN>int class_interface_register(struct class_interface *intf);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void class_interface_unregister(struct class_interface *intf);</SPAN></SPAN> <DD><P>添加一个接口到一个类(或去除它)的函数.</P></DD></DL></DIV></DIV><DIV class=sect2 lang=zh-cn><DIV class=titlepage><DIV><DIV><H3 class=title><A name=Firmware.sect2></A>14.9.5.&nbsp;固件</H3></DIV></DIV></DIV><DIV class=variablelist><DL><DT><SPAN class=term><SPAN>#include &lt;linux/firmware.h&gt;</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int request_firmware(const struct firmware **fw, char *name, struct device *device);</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>int request_firmware_nowait(struct module *module, char *name, struct device *device, void *context, void (*cont)(const struct firmware *fw, void *context));</SPAN></SPAN> <DD><DT><SPAN class=term><SPAN>void release_firmware(struct firmware *fw);</SPAN></SPAN> <DD><P>属性内核固件加载接口的函数.</P></DD></DL></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></DIV></PRE></DIV></DIV></DIV></DIV></DIV></DIV>
                        <DIV></DIV></DIV></TD></TR></TBODY></TABLE>
                  <P style="MARGIN: 5px; LINE-HEIGHT: 150%"><A 
                  href="http://blog.chinaunix.net/u2/78225/showart.php?id=1270012" 
                  target=_blank>回目录 Linux Device Driver书籍</A> </P></TD></TR>
              <TR>
                <TD align=middle height=25><FONT color=#295200>发表于： 2008-09-28 
                  ，修改于： 2008-10-06 16:37，已浏览52次，有评论0条</FONT> <A id=star 
                  title=推荐这篇文章 onclick="NewWindows(this.href);return false;" 
                  href="http://blog.chinaunix.net/u2/star.php?blogid=78225&amp;artid=1270149">推荐</A> 
                  <A id=complaint title=投诉这篇文章 
                  onclick="NewWindows(this.href);return false;" 
                  href="http://blog.chinaunix.net/u2/complaint.php?blogid=78225&amp;artid=1270149">投诉</A> 
                </TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE></TD>
    <TD width=18 
    background="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_right.gif"></TD></TR>
  <TR>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_left_bottom.gif" 
      border=0></TD>
    <TD 
    background="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_bottom.gif">
      <P style="MARGIN: 5px; LINE-HEIGHT: 150%"></P></TD>
    <TD width=18 height=28><IMG alt="" 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/bg_art_right_bottom.gif" 
      border=0></TD></TR></TBODY></TABLE><BR>
<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#a5bd6b cellSpacing=1 
cellPadding=0 width="90%" align=center border=1>
  <TBODY>
  <TR>
    <TD style="COLOR: #295200" bgColor=#eff7de height=25><B>网友评论</B></TD></TR>
  <TR>
    <TD bgColor=#ffffff height=1></TD></TR>
  <TR>
    <TD align=middle bgColor=#f9f5e7>
      <TABLE 
      style="COLOR: #295200; BORDER-COLLAPSE: collapse; WORD-WRAP: break-word" 
      cellSpacing=0 cellPadding=0 width="100%" align=center border=0>
        <TBODY></TBODY></TABLE></TD></TR></TBODY></TABLE><BR>
<TABLE style="BORDER-COLLAPSE: collapse" borderColor=#a5bd6b cellSpacing=1 
cellPadding=0 width="90%" align=center border=1>
  <TBODY>
  <TR>
    <TD style="COLOR: #295200" bgColor=#eff7de height=25><B>发表评论</B></TD></TR>
  <TR>
    <TD bgColor=#ffffff height=1></TD></TR>
  <TR>
    <TD align=middle bgColor=#f9f5e7><IFRAME name=comment 
      src="Linux Device Driver书籍（14）Linux 设备模型 - LDD3 - 嵌入式驱动进行时.files/comment.htm" 
      frameBorder=0 width="100%" 
height=160></IFRAME></TD></TR></TBODY></TABLE></BODY></HTML>
